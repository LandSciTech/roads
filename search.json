[{"path":"https://landscitech.github.io/roads/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"roads Package","text":"vignette provides tutorial use roads package spatial simulation future roads development given resource development scenario. tutorial, borrows heavily demonstration written Kyle Lochhead Tyler Muhly 2018, focus primarily projectRoads function roads package, responsible performing simulation. Example data sets used included package CLUSexample demoScen. context package, resource development scenarios represented three components: Weights Raster Weight Function: weights raster spatial, gridded weight layer covering entire landscape. weight function takes values adjacent weights raster cells inputs returns cost developing new road . Existing Road Network: spatial, representation existing road network within landscape. Landings: set locations new resource development take place. Given input resource development scenario, projectRoads simulate new roads existing road network landings using one four algorithms: Snapping Least-cost path (LCP) Iterative least-cost path (ILCP) Minimum spanning tree (MST) output projectRoads list simulation results referred “sim list”. list contains five elements: roads: projected road network, including new input roads. weightRaster: weights raster, updated reflect new roads added. roadMethod road simulation method used. landings landings used simulation. g graph describes cost paths cell weights raster. updated based new roads vertices connected new roads now weight 0. can used avoid recomputing graph simulation multiple time steps.","code":""},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"setup","dir":"Articles","previous_headings":"Introduction","what":"Setup","title":"roads Package","text":"","code":"library(terra) library(dplyr) library(sf) library(roads)  ## colours for displaying weight raster  if(requireNamespace(\"viridis\", quietly = TRUE)){   # Use colour blind friendly palette if available   rastColours <- c('grey50', viridis::viridis(20)) } else {   rastColours <- c('grey50', terrain.colors(20)) }  # terra objects need to be wrapped to be saved, this unwraps them CLUSexample <- prepExData(CLUSexample)"},{"path":[]},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"weights-raster-and-weight-function","dir":"Articles","previous_headings":"Resource development scenario","what":"1. Weights Raster and Weight Function","title":"roads Package","text":"cost new roads development within landscape determined applying weightFunction weightRaster. weightRaster must provided single, numeric SpatRaster RasterLayer object. cell values raster two adjacent cells provided weightFunction calculate weight edge connecting two cells graph represent cost building road connecting two cells. Two ways calculating cost supported package option users develop . simplest method weightRaster values represent cost building road across cell weightFunction simply take mean values adjacent cells. option included package use slopePenaltyFn. function takes modified DEM raster input determines costs applying base cost grade penalty multiplied % grade adjacent cells. DEM can modified adding barriers raster, either negative values represent high costs (e.g. stream crossing) NAs inaccessible areas (e.g. cliff lake). See ?slopePenaltyFn details. following points apply weightRasters: * Weights existing road segments assumed zero. existing roads 0 weightRaster can “burned ” setting roadsInWeight = FALSE. * extent landscape interest assumed match extent specified weightRaster. * coordinate reference system (CRS) raster must match input data-sets. * cell size (resolution) weightRaster user, important remember unit area road assumed take entire cell. * Areas NA included graph assumed inaccessible roads. landing surrounded NAs connected existing road network error produced. weight raster basic example cost surface weightFunction used average.","code":"weightRaster <- CLUSexample$cost"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"existing-road-network-layer","dir":"Articles","previous_headings":"Resource development scenario","what":"2. Existing road network layer","title":"roads Package","text":"state existing roads network must specified projectRoads method. specification made form sf object geometry type “LINES”, SpatialLines object, RasterLayer, SpatRaster. input roads raster resulting roads returned raster default roadsOut = \"sf\" set geometry collection lines points returned points representing input roads. roads network included CLUSexample data-set raster use line make plotting easier.","code":"## existing roads network roadsLine <- sf::st_sfc(geometry = sf::st_linestring(   matrix(c(0.5, 4.5, 4.5, 4.5),          ncol = 2, byrow = T)  )) %>%   sf::st_as_sf(crs = sf::st_crs(weightRaster))"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"landings-layers","dir":"Articles","previous_headings":"Resource development scenario","what":"3. Landings layer(s)","title":"roads Package","text":"Landings, resource development locations, connected existing road network can specified projectRoads method variety forms. include specification : sf object geometry type “POINTS” “POLYGONs” logical SpatRaster RasterLayer object cell values TRUE landings, SpatialPoints SpatialPointsDataFrame object points representing landings, matrix least two columns, columns 1 2 representing x y coordinates landing locations respectively, SpatialPolygonsor SpatialPolygonsDataFrame object polygons representing landings, landings polygons centroid used destination new roads. control one landing per polygon see Multiple landings per harvest block .  Notice top row raster cost zero, existing road traverses landscape.","code":"## landings as spatial points landings <- roads::CLUSexample$landings  ## plot example scenario plot(weightRaster, col = rastColours, main = 'Example Scenario') plot(roadsLine, add = TRUE) plot(landings, add = TRUE, pch = 19) points(x=5.6,y=4.5,pch=19,xpd=TRUE) text(x=5.8,y=4.5,labels='landing',adj=c(0,0.4),xpd=TRUE) lines(x=c(5.3,5.6),y=c(4.2,4.2),lwd=2,xpd=TRUE) text(x=5.75,y=4.2,labels='roads',adj=c(0,0.3),xpd=TRUE)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"output-format","dir":"Articles","previous_headings":"Resource development scenario","what":"Output format","title":"roads Package","text":"projectRoads accepts wide range classes spatial objects input results returned sf vectors SpatRaster rasters.","code":""},{"path":[]},{"path":[]},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"snapping","dir":"Articles","previous_headings":"Simulation of new roads development > Simulation methods","what":"1. Snapping","title":"roads Package","text":"approach simply ‘snaps’ landing nearest existing road segment. Since snapping done landing also called independent path method.  Using approach, issues arise: parallel roads realistic since branching leads increased numbers roads; costs included (.e., slope barriers like large water bodies). means approach, simple implement, estimate amount simulated roads.","code":"## project new roads using the 'snap' approach projRoads_snap <- roads::projectRoads(landings, weightRaster, roadsLine,                                       roadMethod = 'snap') #> 0s detected in weightRaster raster, these will be considered as existing roads #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_union assumes that they are #> planar #> although coordinates are longitude/latitude, st_nearest_points assumes that #> they are planar  ## plot the weight raster, landings, and roads segments to the landings plot(weightRaster, col = rastColours, main = \"'Snapped' roads\") points(landings, pch = 19, col = 'red')   plot(projRoads_snap$roads, add = TRUE)   ## update legend points(x = 5.5, y = 4.8, pch = 19, xpd = TRUE, col = 'red') text(x = 5.7, y = 4.8, labels = 'landing', adj = c(0, 0.4), xpd = TRUE) lines(x = c(5.3, 5.6), y = c(4.2, 4.2), lwd = 2, xpd = TRUE) text(x = 5.75, y = 4.2, labels = 'roads', adj = c(0, 0.3), xpd = TRUE)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"least-cost-paths-lcp","dir":"Articles","previous_headings":"Simulation of new roads development > Simulation methods","what":"2. Least Cost Paths (LCP)","title":"roads Package","text":"approach builds upon snapping approach assuming ‘cost directed’ path (.e., “wolf runs”) landing existing road network. approach requires cost surface provided used build mathematical graph using igraph takes considerably longer compute. graph built, least cost path landing nearest existing road determined using Dijkstra’s algorithm, implemented shortest_paths function igraph. graph updated graph returned result reflects new roads built.  main disadvantage approach roads developed independently. least cost path may produce parallel redundant roads since path made target corresponding closest point. may mimic road development since road tenures give licensees right limit industrial users using road (.e., gated roads); thereby forcing industrial users consider building nearly parallel road. cases branching, two roads connecting two landings existing road network use least cost path; however, conditional spatial configuration local cost surface existing road network. Thus, amount road developed LCP dependent local cost surface may either higher lower corresponding snap approach.","code":"## project new roads using the 'LCP' approach projRoads_lcp <- roads::projectRoads(landings,                                          weightRaster,                                          roadsLine,                                          roadMethod = 'lcp') #> 0s detected in weightRaster raster, these will be considered as existing roads #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_union assumes that they are #> planar #> although coordinates are longitude/latitude, st_nearest_points assumes that #> they are planar  ## plot the weight raster and overlay it with new roads plot(weightRaster, col = rastColours, main = \"'LCP' roads\") plot(projRoads_lcp$roads, add = TRUE) points(landings, pch = 19, col = 'red')  ## landings points ## legend points(x = 5.5, y = 4.8, pch = 19, xpd = TRUE, col = 'red') text(x = 5.7, y = 4.8, labels = 'landing', adj = c(0, 0.4), xpd = TRUE) lines(x = c(5.3, 5.6), y = c(4.2, 4.2), lwd = 2, xpd = TRUE) text(x = 5.75, y = 4.2, labels = 'roads', adj = c(0, 0.3), xpd = TRUE)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"iterative-least-cost-paths-ilcp","dir":"Articles","previous_headings":"Simulation of new roads development > Simulation methods","what":"3. Iterative Least Cost Paths (ILCP)","title":"roads Package","text":"approach reduces number parallel roads seen LCP method road landing built sequentially cost graph updated roads built earlier can used access landings. order determined ordering argument projectRoads default builds roads closest landings first. prevent build roads order landings supplied use ordering = none.  ILCP approach produces network rather many parallel roads. However, sensitive ordering landings. reverse order landings continue using default ordering closest first. two closest landings tied distance road tie broken order supplied switching produces different road network.","code":"## project new roads using the 'ILCP' approach projRoads_ilcp <- roads::projectRoads(landings,                                          weightRaster,                                          roadsLine,                                          roadMethod = 'ilcp') #> 0s detected in weightRaster raster, these will be considered as existing roads #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_union assumes that they are #> planar #> although coordinates are longitude/latitude, st_nearest_points assumes that #> they are planar  ## plot the weight raster and overlay it with new roads plot(weightRaster, col = rastColours, main = \"'ILCP' roads\") plot(projRoads_ilcp$roads, add = TRUE) points(landings, pch = 19, col = 'red')  ## landings points ## legend points(x = 5.5, y = 4.8, pch = 19, xpd = TRUE, col = 'red') text(x = 5.7, y = 4.8, labels = 'landing', adj = c(0, 0.4), xpd = TRUE) lines(x = c(5.3, 5.6), y = c(4.2, 4.2), lwd = 2, xpd = TRUE) text(x = 5.75, y = 4.2, labels = 'roads', adj = c(0, 0.3), xpd = TRUE) ## project new roads using the 'ILCP' approach projRoads_ilcp2 <- roads::projectRoads(st_coordinates(landings)[4:1,],                                          weightRaster,                                          roadsLine,                                          roadMethod = 'ilcp') #> 0s detected in weightRaster raster, these will be considered as existing roads #> CRS of landings supplied as a matrix is assumed to match the weightRaster #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_union assumes that they are #> planar #> although coordinates are longitude/latitude, st_nearest_points assumes that #> they are planar  ## plot the weight raster and overlay it with new roads plot(weightRaster, col = rastColours, main = \"'ILCP' roads\") plot(projRoads_ilcp2$roads, add = TRUE) points(landings, pch = 19, col = 'red')  ## landings points ## legend points(x = 5.5, y = 4.8, pch = 19, xpd = TRUE, col = 'red') text(x = 5.7, y = 4.8, labels = 'landing', adj = c(0, 0.4), xpd = TRUE) lines(x = c(5.3, 5.6), y = c(4.2, 4.2), lwd = 2, xpd = TRUE) text(x = 5.75, y = 4.2, labels = 'roads', adj = c(0, 0.3), xpd = TRUE)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"minimum-spanning-tree-mst-with-least-cost-paths-lcp","dir":"Articles","previous_headings":"Simulation of new roads development > Simulation methods","what":"4. Minimum Spanning Tree (MST) with Least Cost Paths (LCP)","title":"roads Package","text":"MST approach builds upon LCP approach determining landings connected one another connected existing road network. MST approach, LCPs estimated landings landings existing road network. distances used nodes solving minimum spanning tree. sequence vertices LCPs constructed following solution MST.  MST approach produce least amount roads (relative approaches), given landings allowed connect landings. approach simulates realistic view road branching relative approaches. However, given need get LCP distances, solve MST construct LCPs, likely costly terms computation time.","code":"## project new roads using the 'MST' approach projRoads_mst <- roads::projectRoads(landings,                                          weightRaster,                                         roadsLine,                                          roadMethod = 'mst') #> 0s detected in weightRaster raster, these will be considered as existing roads #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> although coordinates are longitude/latitude, st_union assumes that they are #> planar #> although coordinates are longitude/latitude, st_nearest_points assumes that #> they are planar  ## plot the weight raster and overlay it with new roads plot(weightRaster, col = rastColours, main = \"'MST' roads\") plot(projRoads_mst$roads, add = TRUE) points(landings, pch = 19, col = 'red')  ## landings points ## legend points(x = 5.5, y = 4.8, pch = 19, xpd = TRUE, col = 'red') text(x = 5.7, y = 4.8, labels = 'landing', adj = c(0, 0.4), xpd = TRUE) lines(x = c(5.3, 5.6), y = c(4.2, 4.2), lwd = 2, xpd = TRUE) text(x = 5.75, y = 4.2, labels = 'roads', adj = c(0, 0.3), xpd = TRUE)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"one-time-versus-multi-temporal-simulation","dir":"Articles","previous_headings":"Simulation of new roads development","what":"One-time versus multi-temporal simulation","title":"roads Package","text":"Roads development simulation can performed either single time step (one-time) multiple time steps. section use demonstration scenario demoScen data-set included roads package. four different sets landings.","code":"## colours for displaying weight raster if(requireNamespace(\"viridis\", quietly = TRUE)){   # Use colour blind friendly palette if available   rastColours2 <- c('grey50', viridis::viridis(30)) } else {   rastColours2 <- c('grey50', terrain.colors(30)) }  ## scenario  demoScen <- prepExData(demoScen) scen <- demoScen[[1]] ## landing sets 1 to 4 of this scenario  land.pnts <- scen$landings.points[scen$landings.points$set %in% c(1:4),] ## plot the weight raster and landings par(mar=par('mar')/2) plot(scen$cost.rast, col = rastColours2, main = 'Cost and landings (by set)') plot(land.pnts %>% st_geometry(), add = TRUE, pch = 21, cex = 2, bg = 'white') text(st_coordinates(land.pnts), labels = land.pnts$set, cex = 0.6, adj = c(0.5, 0.3),      xpd = TRUE)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"one-time-simulation","dir":"Articles","previous_headings":"Simulation of new roads development > One-time versus multi-temporal simulation","what":"One-time simulation","title":"roads Package","text":"landings, costs, roads specified projectRoads, one-time road simulation performed returns list object holding projected roads related information. can repeated multiple times different road building scenarios simulation independent previous simulations. appropriate landing set represented alternate scenarios development.  results one-time simulations may fine looking landings scenario/set independently (e.g. representing possible scenario time t=1), likely appropriate cases landings sets follow temporal development sequence (e.g. set 1 development time t=1, set 2 development time t=2, ). Independent one-time simulations take account fact , given time step, existing roads given simulation union existing roads time t=0 roads simulation results leading current step. example, existing roads input simulation time t=2 (landings set 2), union existing roads time t=0 projected roads time t=1 (landings set 1).","code":"## project roads for landing sets 1 to 4, with independent one-time simulations oneTime_sim <- list() ## empty list  for (i in 1:4){   oneTime_sim <- c(oneTime_sim,                        roads::projectRoads(land.pnts[land.pnts$set==i,],                                               scen$cost.rast,                                               scen$cost.rast==0,                                               roadMethod='mst')$roads) } #> 0s detected in weightRaster raster, these will be considered as existing roads #> 0s detected in weightRaster raster, these will be considered as existing roads #> 0s detected in weightRaster raster, these will be considered as existing roads #> 0s detected in weightRaster raster, these will be considered as existing roads  ## plot oldpar <- par(mfrow = c(2, 2), mar = par('mar')/2) for (i in 1:4){   oneTime_sim[[i]][!oneTime_sim[[i]]] <- NA    plot(scen$cost.rast, col = rastColours2,         main = paste0('Landings set ', i),        legend = FALSE)   plot(oneTime_sim[[i]], add = TRUE, col = \"grey50\", legend = FALSE)   plot(st_geometry(land.pnts[land.pnts$set == i, ]), add = TRUE,        pch = 21, cex = 1.5, bg = 'white') } ## raster representing the union of completely independent simulations for multiple sets oneTime_sim <- rast(oneTime_sim) independent <- any(oneTime_sim, na.rm = TRUE) ## set non-road to NA for display purposes independent[!independent] <- NA  ## plot  plot(scen$cost.rast, col = rastColours2,      main = 'Union of independent sim results',      legend = FALSE)  plot(independent, col = 'grey30', add = TRUE, legend = FALSE)  plot(st_geometry(land.pnts), add = TRUE, pch = 21, cex = 1.5, bg = 'white')"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"multi-temporal-simulation","dir":"Articles","previous_headings":"Simulation of new roads development > One-time versus multi-temporal simulation","what":"Multi-temporal simulation","title":"roads Package","text":"Multi-temporal (multiple time steps) roads projections can performed projectRoads, providing list produced previous simulation run (sim list) sim argument landings current time period. function uses sim list starting point need recompute graph used determine least cost path. can implemented loop.","code":"## continuing on with demo scenario 1 ## landing sets 1 to 4 of this scenario as a raster stack land.stack <- scen$landings.stack[[1:4]]  # initialize sim list with first landings set multiTime_sim <- list(projectRoads(land.stack[[1]], scen$cost.rast,                                                 scen$road.line)) #> 0s detected in weightRaster raster, these will be considered as existing roads  # iterate over landings sets using the sim list from the previous run as input for (i in 2:nlyr(land.stack)) {   multiTime_sim <- c(     multiTime_sim,     list(projectRoads(sim =  multiTime_sim[[i-1]], landings = land.stack[[i]]))   )  } #> 0s detected in weightRaster raster, these will be considered as existing roads #> 0s detected in weightRaster raster, these will be considered as existing roads #> 0s detected in weightRaster raster, these will be considered as existing roads  par(mfrow = c(3, 2)) par(mar = par('mar')/2)   plot(scen$cost.rast, col = rastColours2, main = 'Roads at time t = 0',         legend = FALSE)   plot(scen$road.line, col = 'grey30', add = TRUE, legend = FALSE)    for (i in 1:length(multiTime_sim)){   plot(multiTime_sim[[i]]$weightRaster, col = rastColours2,         main = paste0('Roads at time t = ', i), legend = FALSE)   plot(multiTime_sim[[i]]$roads, col = 'grey30', add = TRUE, legend = FALSE)   plot(st_geometry(land.pnts[land.pnts$set == i, ]), add = TRUE, pch = 21,           cex = 1.5, bg = 'white')   if (i >= 2){     plot(st_geometry(land.pnts[land.pnts$set < i, ]), add = TRUE, pch = 1, cex = 1.5)     plot(st_geometry(land.pnts[land.pnts$set == i, ]), add = TRUE, pch = 21,           cex = 1.5, bg = 'white')   } }"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"multiple-landings-per-harvest-block","dir":"Articles","previous_headings":"Simulation of new roads development","what":"Multiple landings per harvest block","title":"roads Package","text":"Often harvest information available polygons showing cutover area point locations landings known. roads package includes getLandingsFromTarget function address situations. default getLandingsFromTarget use centroid polygon landing can also specify sampleType “random” “regular” landingDens landings per unit area generate multiple landing points harvest block.    regular sampling method may realistic since ensures landings spaced apart .","code":"harvPoly <- demoScen[[1]]$landings.poly  outCent <- getLandingsFromTarget(harvPoly) #> Warning: st_point_on_surface assumes attributes are constant over geometries plot(sf::st_geometry(harvPoly)) plot(outCent, col = \"red\", add = TRUE) # Get random sample with density 0.02 pts per unit area outRand <- getLandingsFromTarget(harvPoly, 0.02, sampleType = \"random\") #> you have asked for > 0.001 pts per m2 which is > 1000 pts per km2 and may take a long time prRand <- projectRoads(outRand, scen$cost.rast, scen$road.line) #> 0s detected in weightRaster raster, these will be considered as existing roads  plot(scen$cost.rast, main = \"Random Landings in Harvest Blocks\",      col = rastColours2) plot(harvPoly, add = TRUE) plot(prRand$roads, add = TRUE,  col = \"grey50\") plot(outRand, col = \"red\", add = TRUE) # Get regular sample with density 0.02 pts per unit area outReg <- getLandingsFromTarget(harvPoly, 0.02, sampleType = \"regular\") #> you have asked for > 0.001 pts per m2 which is > 1000 pts per km2 and may take a long time prReg <- projectRoads(outReg, scen$cost.rast,scen$road.line) #> 0s detected in weightRaster raster, these will be considered as existing roads   plot(scen$cost.rast, main = \"Regular Landings in Harvest Blocks\",      col = rastColours2) plot(harvPoly, add = TRUE) plot(prReg$roads, add = TRUE, col = \"grey50\") plot(outReg, col = \"red\", add = TRUE) # clean up  par(oldpar)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"roads Package","text":"vignette partially copied Kyle Lochhead & Tyler Muhly’s 2018 CLUS example","code":""},{"path":"https://landscitech.github.io/roads/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sarah Endicott. Author, maintainer. Kyle Lochhead. Author. Josie Hughes. Author. Patrick Kirby. Author. Majesty Queen Right Canada represented Minister Environment. Copyright holder.            Copyright holder included functions buildSimList, getLandingsFromTarget, pathsToLines, plotRoads, projectRoads, rasterizeLine, rasterToLineSegments Province British Columbia. Copyright holder.            Copyright holder included functions getGraph, lcpList, mstList, shortestPaths, getClosestRoad, buildSnapRoads","code":""},{"path":"https://landscitech.github.io/roads/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Endicott S, Lochhead K, Hughes J, Kirby P (2024). roads: Road Network Projection. R package version 1.1.2,  https://landscitech.github.io/roads/, https://github.com/LandSciTech/roads.","code":"@Manual{,   title = {roads: Road Network Projection},   author = {Sarah Endicott and Kyle Lochhead and Josie Hughes and Patrick Kirby},   year = {2024},   note = {R package version 1.1.2,  https://landscitech.github.io/roads/},   url = {https://github.com/LandSciTech/roads}, }"},{"path":"https://landscitech.github.io/roads/index.html","id":"roads-","dir":"","previous_headings":"","what":"Road Network Projection","title":"Road Network Projection","text":"goal roads simulate road development resource development scenarios.","code":""},{"path":"https://landscitech.github.io/roads/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Road Network Projection","text":"can install released version roads CRAN : development version GitHub :","code":"install.packages(\"roads\") # install.packages(\"devtools\") devtools::install_github(\"LandSciTech/roads\")"},{"path":"https://landscitech.github.io/roads/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Road Network Projection","text":"simulate development roads three inputs needed: current road network (roads), locations connected road network (landings) cost building roads across landscape (cost). Typically roads landings sf objects sp Spatial* objects cost raster.  default projectRoads uses iterative least cost paths algorithm (roadMethod = \"ilcp\") connect landing existing road lowest cost path, updating cost landing connected. methods available : minimum spanning tree least cost paths (roadMethod = \"mst\") connect landings nearest existing road landing following path lowest cost across landings, least cost path (roadMethod = \"lcp\") connects landing nearest road via least cost path independent landings snapping (roadMethod = \"snap\") ignores cost landings simply connects landing nearest road “crow flies”. details use package see vignette vignette(\"roads-vignette\", package = \"roads\")","code":"library(roads) library(raster) #> Warning: package 'raster' was built under R version 4.3.2 #> Warning: package 'sp' was built under R version 4.3.2  # data set installed with roads package demoScen <- prepExData(demoScen) scen <- demoScen[[1]]  prRoads <- projectRoads(landings = scen$landings.points,                          cost = scen$cost.rast,                         roads = scen$road.line,                          plotRoads = TRUE)"},{"path":"https://landscitech.github.io/roads/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Road Network Projection","text":"Copyright (C) 2021 Majesty Queen Right Canada, represented Minister Environment Climate Change. Copyright 2018 Province British Columbia Licensed Apache License, Version 2.0 (“License”); may use file except compliance License. may obtain copy License https://www.apache.org/licenses/LICENSE-2.0 Unless required applicable law agreed writing, software distributed License distributed “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied. See License specific language governing permissions limitations License.","code":""},{"path":"https://landscitech.github.io/roads/reference/CLUSexample.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from the CLUS example — CLUSexample","title":"Data from the CLUS example — CLUSexample","text":"Kyle Lochhead Tyler Muhly's CLUS road simulation example. SpatRaster files created terra package must saved terra::wrap() need unwrapped used. prepExData() provided .","code":""},{"path":"https://landscitech.github.io/roads/reference/CLUSexample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from the CLUS example — CLUSexample","text":"","code":"data(CLUSexample)"},{"path":"https://landscitech.github.io/roads/reference/CLUSexample.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from the CLUS example — CLUSexample","text":"named list : $cost object class PackedSpatRaster representing road cost, $landings object class sf representing landing locations $roads object class PackedSpatRaster representing existing roads","code":""},{"path":"https://landscitech.github.io/roads/reference/CLUSexample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from the CLUS example — CLUSexample","text":"","code":"CLUSexample #> $cost #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Geodetic CRS:  WGS 84 #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  prepExData(CLUSexample) #> $cost #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        :    lyr.1  #> min value   :  0.00000  #> max value   : 19.84622  #>  #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Geodetic CRS:  WGS 84 #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        : lyr.1  #> min value   : FALSE  #> max value   :  TRUE  #>"},{"path":"https://landscitech.github.io/roads/reference/demoScen.html","id":null,"dir":"Reference","previous_headings":"","what":"Demonstration set of 10 input scenarios — demoScen","title":"Demonstration set of 10 input scenarios — demoScen","text":"demonstration set scenarios can used input projectRoads method. data contains \"SpatRaster\" objects must wrapped stored. unwrap use prepExData()","code":""},{"path":"https://landscitech.github.io/roads/reference/demoScen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Demonstration set of 10 input scenarios — demoScen","text":"","code":"data(demoScen)"},{"path":"https://landscitech.github.io/roads/reference/demoScen.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Demonstration set of 10 input scenarios — demoScen","text":"list sub-lists, sub-list representing input scenario. scenarios (sub-lists) contain following components: scen.number: integer value representing scenario number (generated scenarios numbered incrementally 1). road.rast: logical PackedSpatRaster representing existing roads.  TRUE existing road. FALSE existing road. road.line: sf object representing existing roads. cost.rast: PackedSpatRaster representing cost developing new roads given cell. landings.points: sf object representing landings sets landing locations within set. data frame includes field named 'set' contains integer values representing landings set point belongs landings.stack: PackedSpatRaster multiple layers representing landings landings sets. logical layer represents one landings set. Values TRUE landing given set. Values FALSE . landings.poly: sf object representing single set polygonal landings.","code":""},{"path":[]},{"path":"https://landscitech.github.io/roads/reference/demoScen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Demonstration set of 10 input scenarios — demoScen","text":"","code":"demoScen[[1]] #> $scen.number #> [1] 1 #>  #> $road.rast #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $road.line #> Simple feature collection with 4 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 99.5 ymax: 99.5 #> Projected CRS: NAD83 / Conus Albers #>   ID                       geometry #> 1  1 LINESTRING (0.5 59.5, 99.5 ... #> 2  2 LINESTRING (0.5 12.5, 99.5 ... #> 3  3 LINESTRING (78.5 99.5, 14.5... #> 4  4 LINESTRING (0.5 8.5, 99.5 1... #>  #> $cost.rast #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $landings.points #> Simple feature collection with 57 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 4.5 ymin: 4.5 xmax: 96.5 ymax: 99.5 #> Projected CRS: NAD83 / Conus Albers #> First 10 features: #>        lyr.1 set ID          geometry #> 1   9.854914   1  1 POINT (96.5 29.5) #> 2  10.736080   1  2 POINT (67.5 73.5) #> 3   8.799249   2  1 POINT (55.5 97.5) #> 4  10.610051   2  2 POINT (48.5 94.5) #> 5  10.067412   2  3 POINT (37.5 70.5) #> 6  11.688921   2  4 POINT (93.5 90.5) #> 7   9.823934   2  5 POINT (50.5 44.5) #> 8  12.055090   2  6 POINT (51.5 66.5) #> 9  10.630008   2  7 POINT (34.5 78.5) #> 10 11.007803   2  8   POINT (4.5 4.5) #>  #> $landings.stack #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $landings.poly #> Simple feature collection with 6 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 4.5 ymin: 29.5 xmax: 86.5 ymax: 93.5 #> Projected CRS: NAD83 / Conus Albers #>   ID                       geometry #> 1  1 POLYGON ((82.5 67.5, 82.5 6... #> 2  2 POLYGON ((48.5 93.5, 48.5 8... #> 3  3 POLYGON ((34.5 81.5, 34.5 7... #> 4  4 POLYGON ((4.5 47.5, 4.5 29.... #> 5  5 POLYGON ((66.5 42.5, 66.5 3... #> 6  6 POLYGON ((10.5 52.5, 10.5 4... #>  demoScen <- prepExData(demoScen) demoScen[[1]] #> $scen.number #> [1] 1 #>  #> $road.rast #> class       : SpatRaster  #> dimensions  : 100, 100, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 100, 0, 100  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Conus Albers (EPSG:5070)  #> source(s)   : memory #> name        : lyr.1  #> min value   : FALSE  #> max value   :  TRUE  #>  #> $road.line #> Simple feature collection with 4 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 99.5 ymax: 99.5 #> Projected CRS: NAD83 / Conus Albers #>   ID                       geometry #> 1  1 LINESTRING (0.5 59.5, 99.5 ... #> 2  2 LINESTRING (0.5 12.5, 99.5 ... #> 3  3 LINESTRING (78.5 99.5, 14.5... #> 4  4 LINESTRING (0.5 8.5, 99.5 1... #>  #> $cost.rast #> class       : SpatRaster  #> dimensions  : 100, 100, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 100, 0, 100  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Conus Albers (EPSG:5070)  #> source(s)   : memory #> name        :    lyr.1  #> min value   :  0.00000  #> max value   : 14.97291  #>  #> $landings.points #> Simple feature collection with 57 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 4.5 ymin: 4.5 xmax: 96.5 ymax: 99.5 #> Projected CRS: NAD83 / Conus Albers #> First 10 features: #>        lyr.1 set ID          geometry #> 1   9.854914   1  1 POINT (96.5 29.5) #> 2  10.736080   1  2 POINT (67.5 73.5) #> 3   8.799249   2  1 POINT (55.5 97.5) #> 4  10.610051   2  2 POINT (48.5 94.5) #> 5  10.067412   2  3 POINT (37.5 70.5) #> 6  11.688921   2  4 POINT (93.5 90.5) #> 7   9.823934   2  5 POINT (50.5 44.5) #> 8  12.055090   2  6 POINT (51.5 66.5) #> 9  10.630008   2  7 POINT (34.5 78.5) #> 10 11.007803   2  8   POINT (4.5 4.5) #>  #> $landings.stack #> class       : SpatRaster  #> dimensions  : 100, 100, 10  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 100, 0, 100  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Conus Albers (EPSG:5070)  #> source(s)   : memory #> names       : lyr.1, lyr.1, lyr.1, lyr.1, lyr.1, lyr.1, ...  #> min values  : FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, ...  #> max values  :  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE, ...  #>  #> $landings.poly #> Simple feature collection with 6 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 4.5 ymin: 29.5 xmax: 86.5 ymax: 93.5 #> Projected CRS: NAD83 / Conus Albers #>   ID                       geometry #> 1  1 POLYGON ((82.5 67.5, 82.5 6... #> 2  2 POLYGON ((48.5 93.5, 48.5 8... #> 3  3 POLYGON ((34.5 81.5, 34.5 7... #> 4  4 POLYGON ((4.5 47.5, 4.5 29.... #> 5  5 POLYGON ((66.5 42.5, 66.5 3... #> 6  6 POLYGON ((10.5 52.5, 10.5 4... #>"},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":null,"dir":"Reference","previous_headings":"","what":"Moving window approach to get distance from source — getDistFromSource","title":"Moving window approach to get distance from source — getDistFromSource","text":"function provides three different methods calculating distance points landscape \"source\" locations. computationally intensive process function arguments can used balance tradeoffs speed accuracy. Note pfocal versions available development version package.","code":""},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moving window approach to get distance from source — getDistFromSource","text":"","code":"getDistFromSource(src, maxDist, kwidth = 3, method = \"terra\")"},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moving window approach to get distance from source — getDistFromSource","text":"src SpatRaster RasterLayer, values > 0 treated source locations. NA values treated 0s. maxDist Numeric, maximum distance calculated units CRS. kwidth Integer, \"pfocal\" \"terra\" methods width moving window. \"pfocal2\" method aggregation factor. method Character, method use, currently \"terra\" supported CRAN version, \"pfocal\" \"pfocal2\" available development version. See details.","code":""},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moving window approach to get distance from source — getDistFromSource","text":"SpatRaster","code":""},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Moving window approach to get distance from source — getDistFromSource","text":"\"terra\" \"pfocal\" methods use iterative moving window approach assign cell distance based number times moving window repeated included. means moving window function run many times small window relative size raster. maxDist argument determines maximum distance calculated affects number iterations moving window needed. kwidth radius moving window number cells, larger values reducing number iterations needed also reducing granularity distances produced. resulting distances increments kwidth resolution raster. total number iterations maxDist/ kwidth * resolution. difference methods underlying package used moving window. terra package methods handling large rasters writing disk, pfocal package requires raster can held memory matrix. third method \"pfocal2\" uses global moving window calculate distance source. means moving window needs applied window size can large. case maxDist determines total size window. kwidth can used reduce number cells included moving window aggregating source raster factor kwidth. increase speed computation produce results artefacts larger grid may less accurate since output raster disaggregated using bilinear interpolation.","code":""},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Moving window approach to get distance from source — getDistFromSource","text":"","code":"CLUSexample <-  prepExData(CLUSexample) getDistFromSource(CLUSexample$roads, 5, 2) #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        : lyr.1  #> min value   :     0  #> max value   :     4   # \\donttest{  library(sf) #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE  library(terra) #> terra 1.7.71  #make example roads from scratch rds <- data.frame(x = 1:1000/100, y = cos(1:1000/100)) %>%   st_as_sf(coords = c(\"x\", \"y\")) %>%   st_union() %>%   st_cast(\"LINESTRING\")  rds_rast <- rasterize(vect(rds),                       rast(nrows = 50, ncols = 50,                            xmin = 0, xmax = 10,                            ymin = -5, ymax = 5),                       touches = TRUE)  getDistFromSource(rds_rast, 5, 2) #> class       : SpatRaster  #> dimensions  : 50, 50, 1  (nrow, ncol, nlyr) #> resolution  : 0.2, 0.2  (x, y) #> extent      : 0, 10, -5, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        : layer  #> min value   :   0.0  #> max value   :   5.2  # }"},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":null,"dir":"Reference","previous_headings":"","what":"Get landing points inside harvest blocks — getLandingsFromTarget","title":"Get landing points inside harvest blocks — getLandingsFromTarget","text":"Generate landing points inside polygons representing harvested area. three different sampling types available: \"centroid\" default return centroid point inside polygon centroid (see sf::st_point_on_surface()); \"random\" takes random sample based given landingDens see (sf::st_sample()); \"regular\" intersects polygons regular grid cell size sqrt(1/landingDens), polygon intersect grid centroid used.","code":""},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get landing points inside harvest blocks — getLandingsFromTarget","text":"","code":"getLandingsFromTarget(harvest, landingDens = NULL, sampleType = \"centroid\")"},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get landing points inside harvest blocks — getLandingsFromTarget","text":"harvest sf, SpatialPolygons RasterLayer object harvested areas. RasterLayer one unique value 0 value run separately produce different results 0/1 raster much slower. landingDens number landings per unit area. units CRS harvest. Note 0.001 points per m2 > 1000 points per km2 number usually small projected CRS. sampleType character. \"centroid\" (default), \"regular\" \"random\". Centroid returns one landing per harvest block, guaranteed harvest block sf objects rasters. Regular returns points grid density landingDens overlap harvested areas. Random returns random set points polygon number determined area polygons landingDens. harvest raster centroid always returned one landings ensure harvest areas get least one landing.","code":""},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get landing points inside harvest blocks — getLandingsFromTarget","text":"sf simple feature collection ID column POINT geometry","code":""},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get landing points inside harvest blocks — getLandingsFromTarget","text":"Note landingDens points per unit area unit area determined CRS. projected CRS likely small number .e. < 0.001.","code":""},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get landing points inside harvest blocks — getLandingsFromTarget","text":"","code":"doPlots <- interactive() demoScen <- prepExData(demoScen)  polys <- demoScen[[1]]$landings.poly[1:2,]  # Get centroid outCent <- getLandingsFromTarget(polys) #> Warning: st_point_on_surface assumes attributes are constant over geometries  if(doPlots){   plot(sf::st_geometry(polys))   plot(outCent, col = \"red\", add = TRUE) }  # Get random sample with density 0.1 points per unit area outRand <- getLandingsFromTarget(polys, 0.1, sampleType = \"random\") #> you have asked for > 0.001 pts per m2 which is > 1000 pts per km2 and may take a long time  if(doPlots){   plot(sf::st_geometry(polys))   plot(outRand, col = \"red\", add = TRUE) }  # Get regular sample with density 0.1 points per unit area outReg <- getLandingsFromTarget(polys, 0.1, sampleType = \"regular\") #> you have asked for > 0.001 pts per m2 which is > 1000 pts per km2 and may take a long time  if(doPlots){   plot(sf::st_geometry(polys))   plot(outReg, col = \"red\", add = TRUE) }"},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot projected roads — plotRoads","title":"Plot projected roads — plotRoads","text":"Plot results projectRoads","code":""},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot projected roads — plotRoads","text":"","code":"plotRoads(sim, mainTitle, subTitle = paste0(\"Method: \", sim$roadMethod), ...)"},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot projected roads — plotRoads","text":"sim sim list result projectRoads mainTitle title plot subTitle sub title plot, default roadMethod used ... arguments passed raster plot call weightRaster","code":""},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot projected roads — plotRoads","text":"Creates plot using base graphics","code":""},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot projected roads — plotRoads","text":"","code":"CLUSexample <- prepExData(CLUSexample) prRes <- projectRoads(CLUSexample$landings, CLUSexample$cost, CLUSexample$roads) #> 0s detected in weightRaster raster, these will be considered as existing roads if(interactive()){   plotRoads(prRes, \"Title\") }"},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare example data — prepExData","title":"Prepare example data — prepExData","text":"Prepare example data included package contain wrapped terra objects. applies terra::unwrap() recursively list provided PackedSpatRasters converted SpatRasters.","code":""},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare example data — prepExData","text":"","code":"prepExData(x)"},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare example data — prepExData","text":"x list containing elements packed SpatRasters.","code":""},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare example data — prepExData","text":"list unwrapped SpatRasters","code":""},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare example data — prepExData","text":"","code":"CLUSexample #> $cost #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Geodetic CRS:  WGS 84 #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  prepExData(CLUSexample) #> $cost #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        :    lyr.1  #> min value   :  0.00000  #> max value   : 19.84622  #>  #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Geodetic CRS:  WGS 84 #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        : lyr.1  #> min value   : FALSE  #> max value   :  TRUE  #>"},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":null,"dir":"Reference","previous_headings":"","what":"Project road network — projectRoads","title":"Project road network — projectRoads","text":"Project road locations based existing roads, planned landings, weights raster conjunction weighting function determines cost build road two cells raster.","code":""},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project road network — projectRoads","text":"","code":"projectRoads(   landings = NULL,   weightRaster = NULL,   roads = NULL,   roadMethod = \"ilcp\",   plotRoads = FALSE,   mainTitle = \"\",   neighbourhood = \"octagon\",   weightFunction = function(x1, x2, ...) (x1 + x2)/2,   sim = NULL,   roadsOut = NULL,   roadsInWeight = TRUE,   ordering = \"closest\",   roadsConnected = FALSE,   ... )  # S4 method for ANY,ANY,ANY,ANY,ANY,ANY,ANY,ANY,missing projectRoads(   landings = NULL,   weightRaster = NULL,   roads = NULL,   roadMethod = \"ilcp\",   plotRoads = FALSE,   mainTitle = \"\",   neighbourhood = \"octagon\",   weightFunction = function(x1, x2, ...) (x1 + x2)/2,   sim = NULL,   roadsOut = NULL,   roadsInWeight = TRUE,   ordering = \"closest\",   roadsConnected = FALSE,   ... )  # S4 method for ANY,ANY,ANY,ANY,ANY,ANY,ANY,ANY,list projectRoads(   landings = NULL,   weightRaster = NULL,   roads = NULL,   roadMethod = \"ilcp\",   plotRoads = FALSE,   mainTitle = \"\",   neighbourhood = \"octagon\",   weightFunction = function(x1, x2, ...) (x1 + x2)/2,   sim = NULL,   roadsOut = NULL,   roadsInWeight = TRUE,   ordering = \"closest\",   roadsConnected = FALSE,   ... )"},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project road network — projectRoads","text":"landings sf polygons points, RasterLayer, SpatialPolygons*, SpatialPoints*, matrix, containing features connected road network. Matrix contain columns x, y coordinates, columns ignored. weightRaster SpatRaster RasterLayer. weights Raster existing roads must cells weight 0. existing roads 0 weight set roadsInWeight = FALSE burned . roads sf lines, SpatialLines*, RasterLayer, SpatRaster. Existing road network. roadMethod Character. Options \"ilcp\", \"mst\", \"lcp\", \"snap\". plotRoads Boolean. resulting road network plotted. Default FALSE. mainTitle Character. title plot neighbourhood Character. 'rook','queen', 'octagon'. cells considered adjacent. 'octagon' option modified version queen's 8 cell neighbourhood diagonals weights 2^0.5x higher horizontal/vertical weights. weightFunction function. Method calculating weight edge two nodes value weights raster nodes (x1 x2). Default mean. Functions symmetric, meaning value returned depend ordering x1 x2. functions must include arguments x1, x2 .... sim list. Returned previous iteration projectRoads. weightRaster, roads, roadMethod ignored sim list provided. roadsOut Character. Either \"raster\", \"sf\" NULL. \"raster\" roads returned raster sim list. \"sf\" roads returned sf object contain lines roads input sf lines geometry collection lines points roads input raster. points geometry collection represent existing roads new roads created lines. NULL (default) returned roads sf input sf Spatial* raster input raster. roadsInWeight Logical. default TRUE means weightRaster assumed include existing roads 0. FALSE roads \"burned \" weightRaster weight 0. ordering character. order roads built landings roadMethod = \"ilcp\". Options \"closest\" (default) landings closest existing roads accessed first, \"none\" landings accessed order provided . roadsConnected Logical. roads fully connected? TRUE roadMethod = \"mst\" MST graph can simplified projection faster ... Optional additional arguments weightFunction","code":""},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project road network — projectRoads","text":"list components: roads: projected road network, including new input roads. weightRaster: weights raster, updated 0 new roads added. roadMethod: road simulation method used. landings: landings used simulation. g: graph describes cost paths cell weightRaster. updated based new roads vertices connected new roads now weight 0. can used avoid recomputing graph simulation multiple time steps.","code":""},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project road network — projectRoads","text":"Four different methods projecting road networks implemented: \"snap\": Connects landing directly closest road without reference weights landings. \"lcp\": Least Cost Path connects landing closest point road determining least cost path based weights raster provided, consider landings. \"ilcp\": Iterative Least Cost Path, \"lcp\" builds path sequentially later roads use earlier roads. sequence landings determined ordering \"closest\" default, option \"none\" use order landings supplied . \"mst\": Minimum Spanning Tree connects landings road determining least cost path road landings based weight raster.","code":""},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project road network — projectRoads","text":"","code":"CLUSexample <- prepExData(CLUSexample) doPlots <- interactive()  projectRoads(CLUSexample$landings, CLUSexample$cost, CLUSexample$roads,              \"lcp\", plotRoads = doPlots, mainTitle = \"CLUSexample\") #> 0s detected in weightRaster raster, these will be considered as existing roads #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Geodetic CRS:  WGS 84 #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        : lyr.1  #> min value   : FALSE  #> max value   :  TRUE  #>  #> $g #> IGRAPH 9d4ee7b U-W- 25 72 --  #> + attr: weight (e/n) #> + edges from 9d4ee7b: #>  [1]  1-- 2  1-- 6  1-- 7  2-- 3  2-- 6  2-- 7  2-- 8  3-- 4  3-- 7  3-- 8 #> [11]  3-- 9  4-- 5  4-- 8  4-- 9  4--10  5-- 9  5--10  6-- 7  6--11  6--12 #> [21]  7-- 8  7--11  7--12  7--13  8-- 9  8--12  8--13  8--14  9--10  9--13 #> [31]  9--14  9--15 10--14 10--15 11--12 11--16 11--17 12--13 12--16 12--17 #> [41] 12--18 13--14 13--17 13--18 13--19 14--15 14--18 14--19 14--20 15--19 #> [51] 15--20 16--17 16--21 16--22 17--18 17--21 17--22 17--23 18--19 18--22 #> [61] 18--23 18--24 19--20 19--23 19--24 19--25 20--24 20--25 21--22 22--23 #> [71] 23--24 24--25 #>  #> $weightRaster #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        :    lyr.1  #> min value   :  0.00000  #> max value   : 19.84622  #>  #> $roadMethod #> [1] \"lcp\" #>    # More realistic examples that take longer to run # \\donttest{  demoScen <- prepExData(demoScen)  ### using:  scenario 1 / sf landings / iterative least-cost path (\"ilcp\") # demo scenario 1 scen <- demoScen[[1]]  # landing set 1 of scenario 1: land.pnts <- scen$landings.points[scen$landings.points$set==1,]  prRes <- projectRoads(land.pnts, scen$cost.rast, scen$road.line, \"ilcp\",                          plotRoads = doPlots, mainTitle = \"Scen 1: SPDF-LCP\") #> 0s detected in weightRaster raster, these will be considered as existing roads  ### using: scenario 1 / SpatRaster landings / minimum spanning tree (\"mst\") # demo scenario 1 scen <- demoScen[[1]]  # the RasterLayer version of landing set 1 of scenario 1: land.rLyr <- scen$landings.stack[[1]]  prRes <- projectRoads(land.rLyr, scen$cost.rast, scen$road.line, \"mst\",                          plotRoads = doPlots, mainTitle = \"Scen 1: Raster-MST\") #> 0s detected in weightRaster raster, these will be considered as existing roads   ### using: scenario 2 / matrix landings raster roads / snapping (\"snap\") # demo scenario 2 scen <- demoScen[[2]]  # landing set 5 of scenario 2, as matrix: land.mat  <- scen$landings.points[scen$landings.points$set==5,] |>   sf::st_coordinates()  prRes <- projectRoads(land.mat, scen$cost.rast, scen$road.rast, \"snap\",                       plotRoads = doPlots, mainTitle = \"Scen 2: Matrix-Snap\") #> 0s detected in weightRaster raster, these will be considered as existing roads #> CRS of landings supplied as a matrix is assumed to match the weightRaster  ## using scenario 7 / Polygon landings raster / minimum spanning tree # demo scenario 7 scen <- demoScen[[7]] # rasterize polygonal landings of demo scenario 7: land.polyR <- terra::rasterize(scen$landings.poly, scen$cost.rast)  prRes <- projectRoads(land.polyR, scen$cost.rast, scen$road.rast, \"mst\",                          plotRoads = doPlots, mainTitle = \"Scen 7: PolyRast-MST\") #> 0s detected in weightRaster raster, these will be considered as existing roads # }"},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert raster to lines — rasterToLineSegments","title":"Convert raster to lines — rasterToLineSegments","text":"Converts rasters represent lines sf object.","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert raster to lines — rasterToLineSegments","text":"","code":"rasterToLineSegments(rast, method = \"mst\")"},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert raster to lines — rasterToLineSegments","text":"rast raster representing lines values > 0 assumed lines method method building lines. See Details","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert raster to lines — rasterToLineSegments","text":"sf simple feature collection","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert raster to lines — rasterToLineSegments","text":"method = \"nearest\" raster first converted points lines drawn nearest points. two different ways connect points distance kept can cause doubled lines. USE CAUTION. method = \"mst\" converts raster points, reclassifies raster roads 0 cells 1 uses projectRoads connect points minimum spanning tree. always connect raster cells slower double lines often. Neither method likely work large rasters","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert raster to lines — rasterToLineSegments","text":"","code":"CLUSexample <- prepExData(CLUSexample) # works well for very simple roads roadLine1 <- rasterToLineSegments(CLUSexample$roads) #> Warning: No 0s detected in weightRaster. If existing roads have not been included in the weightRaster set roadsInWeight = FALSE to have them burned in  # longer running more realistic examples # \\donttest{ demoScen <- prepExData(demoScen) # mst method works well in this case roadLine2 <- rasterToLineSegments(demoScen[[1]]$road.rast) #> Warning: No 0s detected in weightRaster. If existing roads have not been included in the weightRaster set roadsInWeight = FALSE to have them burned in  # nearest method has doubled line where the two roads meet roadLine3 <- rasterToLineSegments(demoScen[[1]]$road.rast, method = \"nearest\")  # The mst method can also produce odd results in some cases roadLine4 <- rasterToLineSegments(demoScen[[4]]$road.rast) #> Warning: No 0s detected in weightRaster. If existing roads have not been included in the weightRaster set roadsInWeight = FALSE to have them burned in  # }"},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":null,"dir":"Reference","previous_headings":"","what":"Faster rasterize for lines — rasterizeLine","title":"Faster rasterize for lines — rasterizeLine","text":"Rasterize line using stars fasterize work lines rasterize slow. Deprecated use terra::rasterize","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Faster rasterize for lines — rasterizeLine","text":"","code":"rasterizeLine(sfLine, rast, value)"},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Faster rasterize for lines — rasterizeLine","text":"sfLine sf object rasterized rast raster use template output raster value number value give background ie 0 NA","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Faster rasterize for lines — rasterizeLine","text":"RasterLayer value cells touch line row index line sf","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Faster rasterize for lines — rasterizeLine","text":"","code":"CLUSexample <- prepExData(CLUSexample) roadsLine <- sf::st_sf(geometry = sf::st_sfc(sf::st_linestring( matrix(c(0.5, 4.5, 4.5, 4.51),        ncol = 2, byrow = TRUE)  )))  # Deprecated rasterizeLine(roadsLine, CLUSexample$cost, 0)    # Use terra::rasterize terra::rasterize(roadsLine, CLUSexample$cost, background = 0) #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1"},{"path":"https://landscitech.github.io/roads/reference/roads-package.html","id":null,"dir":"Reference","previous_headings":"","what":"roads: Road Network Projection — roads-package","title":"roads: Road Network Projection — roads-package","text":"Project road network development based existing road network, target locations connected roads cost surface. Road projection methods include minimum spanning tree least cost path (Kruskal's algorithm (1956) doi:10.2307/2033241 ), least cost path (Dijkstra's algorithm (1959) doi:10.1007/BF01386390 ) snapping. road network projection methods ideal use land cover change projection models.","code":""},{"path":[]},{"path":"https://landscitech.github.io/roads/reference/roads-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"roads: Road Network Projection — roads-package","text":"Maintainer: Sarah Endicott sarah.endicott@ec.gc.ca (ORCID) Authors: Kyle Lochhead Kyle.Lochhead@gov.bc.ca Josie Hughes josie.hughes@ec.gc.ca Patrick Kirby contributors: Majesty Queen Right Canada represented Minister Environment (Copyright holder included functions buildSimList, getLandingsFromTarget, pathsToLines, plotRoads, projectRoads, rasterizeLine, rasterToLineSegments) [copyright holder] Province British Columbia (Copyright holder included functions getGraph, lcpList, mstList, shortestPaths, getClosestRoad, buildSnapRoads) [copyright holder]","code":""},{"path":"https://landscitech.github.io/roads/reference/slopePenaltyFn.html","id":null,"dir":"Reference","previous_headings":"","what":"Grade penalty edge weight function — slopePenaltyFn","title":"Grade penalty edge weight function — slopePenaltyFn","text":"Method calculating weight edge two nodes value input raster nodes (x1 x2), designed single DEM input. method assumes input raster : NA indicates road built Negative values costs crossing streams barriers crossable expensive. Edges link barrier penalty (negative value) nodes assigned largest barrier penalty weight. Zero values assumed existing roads. values interpreted elevation units raster map (difference two cells equal map resolution can interpreted 100% grade) simplified version grade penalty approach taken Anderson Nelson: approach distinguish adverse favourable grades. Default construction cost values BC interior appraisal manual. approach ignores (unknown) grade penalties beside roads barriers order avoid increased memory computational burden associated multiple input rasters.","code":""},{"path":"https://landscitech.github.io/roads/reference/slopePenaltyFn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grade penalty edge weight function — slopePenaltyFn","text":"","code":"slopePenaltyFn(   x1,   x2,   resolution = 1,   baseCost = 16178,   limit = 20,   penalty = 504,   limitWeight = NA )"},{"path":"https://landscitech.github.io/roads/reference/slopePenaltyFn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grade penalty edge weight function — slopePenaltyFn","text":"x1, x2 Value input raster two nodes. difference 1 implies 100% slope. resolution Resolution input raster. Resolution x1/x2 units. baseCost Construction cost 0% grade road. limit Maximum grade (%) roads can built. penalty Cost increase associated additional % increase road grade. limitWeight Value assigned edges exceed grade limit. Try setting high (NA) value encountering problems disconnected graphs.","code":""},{"path":"https://landscitech.github.io/roads/reference/slopePenaltyFn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grade penalty edge weight function — slopePenaltyFn","text":"","code":"slopePenaltyFn(0.5,0.51) #> [1] 16682 slopePenaltyFn(0.5,0.65) #> [1] 23738 # grade > 20% so NA slopePenaltyFn(0.5,0.75) #> [1] NA"},{"path":"https://landscitech.github.io/roads/news/index.html","id":"roads-112","dir":"Changelog","previous_headings":"","what":"roads 1.1.2","title":"roads 1.1.2","text":"Change dynamic least cost paths (DLCP) iterative least cost paths (ILCP) throughout Change default roadMethod \"ilcp\" projectRoads Add ability use custom weightFunction add weightFunction slopePenaltyFn determines grade two cells Change argument name cost weightRaster since longer represents cost surface can now inputs weightFunction. Also change roadsInCost roadsInWeight. returned roads longer unioned together.","code":""},{"path":"https://landscitech.github.io/roads/news/index.html","id":"roads-111","dir":"Changelog","previous_headings":"","what":"roads 1.1.1","title":"roads 1.1.1","text":"CRAN release: 2023-06-24 Fix issue updates terra causing roads break process removed raster sp dependencies converted example data terra sf formats. requires new function prepExData unwrap terra objects needed wrapped storage","code":""},{"path":"https://landscitech.github.io/roads/news/index.html","id":"roads-110","dir":"Changelog","previous_headings":"","what":"roads 1.1.0","title":"roads 1.1.0","text":"CRAN release: 2023-02-02 converted using terra throughout package. raster objects still accepted converted terra formats. Added getDistFromSource function use moving windows quickly get raster distance nearest source (e.g road). remove SpaDES.tools dependency archived CRAN equivalent method terra now. returned cost raster now includes projected roads cost 0. makes easier loop additional road building time change previous version input cost surface returned.","code":""},{"path":"https://landscitech.github.io/roads/news/index.html","id":"roads-100","dir":"Changelog","previous_headings":"","what":"roads 1.0.0","title":"roads 1.0.0","text":"CRAN release: 2022-06-22 Added NEWS.md file track changes package.","code":""}]
