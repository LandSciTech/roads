[{"path":"https://landscitech.github.io/roads/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://landscitech.github.io/roads/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"roads Package","text":"tutorial using projectRoads function roads package project forest road networks borrows heavily demonstration written Kyle Lochhead Tyler Muhly 2018. Example data sets used included package CLUSexample demoScen. three main inputs projectRoads function: weightRaster weightFunction: together, determine cost build road two adjacent raster cells. weightRaster spatial gridded raster values locations road construction possible. weightFunction calculates cost constructing road two adjacent raster cells weightRaster cells. Existing Road Network: spatial representation existing road network. Landings: set locations connected existing road network constructing new roads. projectRoads simulates new roads connect landings existing road network using one four methods: Snap Least-cost path (LCP) Iterative least-cost path (ILCP) Minimum spanning tree (MST) output projectRoads list simulation results referred “sim list”. list contains five elements: roads: projected road network, including new input roads. weightRaster: updated weightRaster new old roads value 0. roadMethod road simulation method used. landings landings used simulation. g graph describes cost paths cell updated weightRaster. Edges vertices connected new roads weight 0. g can used avoid cost rebuilding graph simulation multiple time steps.","code":""},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"setup","dir":"Articles","previous_headings":"Introduction","what":"Setup","title":"roads Package","text":"","code":"library(terra) library(dplyr) library(sf) library(roads)  ## colours for displaying weight raster  if(requireNamespace(\"viridis\", quietly = TRUE)){   # Use colour blind friendly palette if available   rastColours <- c('grey50', viridis::viridis(20)) } else {   rastColours <- c('grey50', terrain.colors(20)) }  # terra objects need to be wrapped to be saved, this unwraps them CLUSexample <- prepExData(CLUSexample)"},{"path":[]},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"weights-raster-and-weight-function","dir":"Articles","previous_headings":"Resource development scenario","what":"1. Weights Raster and Weight Function","title":"roads Package","text":"cost constructing road segment connect adjacent cells determined weightFunction weightRaster. weightFunction calculates cost construction adjacent cells value weightRaster cells distance . Two methods calculating costs provided, option users develop . default weightFunction = simpleCostFn assumes values weightRaster represent cost building road across cell, sets cost mean value adjacent cells. alternative weightFunction = gradePenaltyFn penalizes road construction steep grades setting cost function difference weightRaster values adjacent cells. case, weightRaster elevation raster can also include barriers. See ?gradePenaltyFn details. following points apply weightRasters: weightRaster must single, numeric SpatRaster RasterLayer object. coordinate reference system (CRS) raster must match CRS existing road network landings. weightRaster determines extent area considered new road construction. Existing roads landings outside extent weightRaster ignored. Values cells include existing roads 0, 0 values assumed existing roads. Existing roads can added weightRaster setting roadsInWeight = FALSE. resolution weightRaster determines resolution constructed road network. Adjacent cells connected straight road segments, cell either contains road, . NA values weightRaster included graph, considered road construction. landing surrounded NAs connected existing road network produce error. weight raster basic example cost surface weightFunction used average.","code":"weightRaster <- CLUSexample$cost"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"existing-road-network-layer","dir":"Articles","previous_headings":"Resource development scenario","what":"2. Existing road network layer","title":"roads Package","text":"network existing roads must provided sf object geometry type \"LINES\", SpatialLines object, RasterLayer, SpatRaster. input roads raster projected roads also returned raster default, roadsOut = \"sf\" geometry collection lines points returned points representing input roads. road network included CLUSexample data-set raster use line plotting.","code":"## existing roads network roadsLine <- sf::st_sfc(geometry = sf::st_linestring(   matrix(c(0.5, 4.5, 4.5, 4.5),          ncol = 2, byrow = T)  )) %>%   sf::st_as_sf(crs = sf::st_crs(weightRaster))"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"landings-layers","dir":"Articles","previous_headings":"Resource development scenario","what":"3. Landings layer(s)","title":"roads Package","text":"Landings, resource development locations, connected existing road network can specified variety forms: sf object geometry type \"POINTS\" \"POLYGON\" logical SpatRaster RasterLayer object cell values TRUE landings, SpatialPoints SpatialPointsDataFrame object points representing landings, matrix least two columns, columns 1 2 representing x y coordinates landing locations respectively, SpatialPolygonsor SpatialPolygonsDataFrame object polygons representing landings, landings polygons centroid used destination new roads. control specify one landing per polygon see Multiple landings per harvest section .  Notice top row raster cost zero existing road traverses landscape.","code":"## landings as spatial points landings <- roads::CLUSexample$landings  ## plot example scenario par(omi = c(0,0,0,1.2)) plot(weightRaster, col = rastColours, main = 'Example Scenario') plot(roadsLine, add = TRUE) plot(landings, add = TRUE, pch = 19) legend(x = 7.25, y = 5, legend = c(\"landings\", \"roads\"), pch = c(19, NA),         lwd = c(NA, 1),        xpd = NA, inset = -0.1, xjust = 1)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"output-format","dir":"Articles","previous_headings":"Resource development scenario","what":"Output format","title":"roads Package","text":"projectRoads accepts wide range classes spatial objects input results returned sf vectors SpatRaster rasters.","code":""},{"path":[]},{"path":[]},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"snapping","dir":"Articles","previous_headings":"Simulation of new roads development > Simulation methods","what":"1. Snapping","title":"roads Package","text":"approach simply ‘snaps’ landing nearest (Euclidean distance) existing road segment, ignoring spatial variation road construction cost locations landings access roads.  simple approach gives unrealistically redundant road network without branches account variation road construction costs across landscape.","code":"## project new roads using the 'snap' approach projRoads_snap <- roads::projectRoads(landings, weightRaster, roadsLine,                                       roadMethod = 'snap') #> 0s detected in weightRaster raster, these will be considered as existing roads par(omi = c(0,0,0,1.2)) ## plot the weight raster, landings, and roads segments to the landings plot(weightRaster, col = rastColours, main = \"'Snapped' roads\") points(landings, pch = 19)   plot(projRoads_snap$roads, add = TRUE)   ## update legend legend(x = 7.25, y = 5, legend = c(\"landings\", \"roads\"), pch = c(19, NA),         lwd = c(NA, 1),        xpd = NA, inset = -0.1, xjust = 1)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"least-cost-paths-lcp","dir":"Articles","previous_headings":"Simulation of new roads development > Simulation methods","what":"2. Least Cost Paths (LCP)","title":"roads Package","text":"least cost paths method builds ‘cost directed’ path (.e., “wolf runs”) landing existing road network. mathematical graph node non-NA cell weightRaster edge weights determined weightFunction built using igraph. graph used compute least cost paths landing nearest existing road using Dijkstra’s algorithm implemented shortest_paths function igraph. Graph weights updated include new roads new roads identified.  main disadvantage approach roads developed independently, tends produce parallel redundant roads. mimic road development cases licensees restrict others using road (.e., gated roads), thereby force others consider building nearly parallel road. cases branching, two roads connecting two landings existing road network use least cost path; however, conditional spatial configuration local cost surface existing road network.","code":"## project new roads using the 'LCP' approach projRoads_lcp <- roads::projectRoads(landings,                                          weightRaster,                                          roadsLine,                                          roadMethod = 'lcp') #> 0s detected in weightRaster raster, these will be considered as existing roads par(omi = c(0,0,0,1.2)) ## plot the weight raster and overlay it with new roads plot(weightRaster, col = rastColours, main = \"'LCP' roads\") plot(projRoads_lcp$roads, add = TRUE) points(landings, pch = 19)  ## legend legend(x = 7.25, y = 5, legend = c(\"landings\", \"roads\"), pch = c(19, NA),         lwd = c(NA, 1),        xpd = NA, inset = -0.1, xjust = 1)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"iterative-least-cost-paths-ilcp","dir":"Articles","previous_headings":"Simulation of new roads development > Simulation methods","what":"3. Iterative Least Cost Paths (ILCP)","title":"roads Package","text":"approach builds fewer redundant roads LCP method graph edge weights updated landing accessed, roads built earlier can reused access landings. order determined ordering argument projectRoads; default closest landings accessed first. alternative ordering = none builds roads order landings supplied user.  ILCP approach produces realistic branching network less redundancy. However, sensitive ordering landings. reverse order landings continue using default ordering closest first. two closest landings tied distance road tie broken order supplied switching produces different road network.","code":"## project new roads using the 'ILCP' approach projRoads_ilcp <- roads::projectRoads(landings,                                          weightRaster,                                          roadsLine,                                          roadMethod = 'ilcp') #> 0s detected in weightRaster raster, these will be considered as existing roads par(omi = c(0,0,0,1.2)) ## plot the weight raster and overlay it with new roads plot(weightRaster, col = rastColours, main = \"'ILCP' roads\") plot(projRoads_ilcp$roads, add = TRUE) points(landings, pch = 19)  ## landings points ## legend legend(x = 7.25, y = 5, legend = c(\"landings\", \"roads\"), pch = c(19, NA),         lwd = c(NA, 1),        xpd = NA, inset = -0.1, xjust = 1) ## project new roads using the 'ILCP' approach projRoads_ilcp2 <- roads::projectRoads(st_coordinates(landings)[4:1,],                                          weightRaster,                                          roadsLine,                                          roadMethod = 'ilcp') #> 0s detected in weightRaster raster, these will be considered as existing roads #> CRS of landings supplied as a matrix is assumed to match the weightRaster par(omi = c(0,0,0,1.2)) ## plot the weight raster and overlay it with new roads plot(weightRaster, col = rastColours, main = \"'ILCP' roads\") plot(projRoads_ilcp2$roads, add = TRUE) points(landings, pch = 19)  ## landings points ## legend legend(x = 7.25, y = 5, legend = c(\"landings\", \"roads\"), pch = c(19, NA),         lwd = c(NA, 1),        xpd = NA, inset = -0.1, xjust = 1)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"minimum-spanning-tree-mst-with-least-cost-paths-lcp","dir":"Articles","previous_headings":"Simulation of new roads development > Simulation methods","what":"4. Minimum Spanning Tree (MST) with Least Cost Paths (LCP)","title":"roads Package","text":"MST approach builds upon LCP approach determining landings connected one another connected existing road network. MST approach, LCPs estimated landings landings existing road network. distances used nodes solving minimum spanning tree network minimizes overall cost connecting landings existing road network.  MST approach produce fewer roads approaches, realistic branching patterns. However, also computationally costly methods.","code":"## project new roads using the 'MST' approach projRoads_mst <- roads::projectRoads(landings,                                          weightRaster,                                         roadsLine,                                          roadMethod = 'mst') #> 0s detected in weightRaster raster, these will be considered as existing roads par(omi = c(0,0,0,1.2)) ## plot the weight raster and overlay it with new roads plot(weightRaster, col = rastColours, main = \"'MST' roads\") plot(projRoads_mst$roads, add = TRUE) points(landings, pch = 19)  ## legend legend(x = 7.25, y = 5, legend = c(\"landings\", \"roads\"), pch = c(19, NA),         lwd = c(NA, 1),        xpd = NA, inset = -0.1, xjust = 1)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"one-time-versus-multi-temporal-simulation","dir":"Articles","previous_headings":"Simulation of new roads development","what":"One-time versus multi-temporal simulation","title":"roads Package","text":"Roads can projected single time step (one-time) multiple time steps. demonstrate construction multiple time steps use demonstration scenario demoScen data-set included roads package. scenario includes four different sets landings.","code":"## colours for displaying weight raster if(requireNamespace(\"viridis\", quietly = TRUE)){   # Use colour blind friendly palette if available   rastColours2 <- c('grey50', viridis::viridis(30)) } else {   rastColours2 <- c('grey50', terrain.colors(30)) }  ## scenario  demoScen <- prepExData(demoScen) scen <- demoScen[[1]] ## landing sets 1 to 4 of this scenario  land.pnts <- scen$landings.points[scen$landings.points$set %in% c(1:4),] ## plot the weight raster and landings par(mar=par('mar')/2) plot(scen$cost.rast, col = rastColours2, main = 'Cost and landings (by set)') plot(land.pnts %>% st_geometry(), add = TRUE, pch = 21, cex = 2, bg = 'white') text(st_coordinates(land.pnts), labels = land.pnts$set, cex = 0.6, adj = c(0.5, 0.3),      xpd = TRUE)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"one-time-simulation","dir":"Articles","previous_headings":"Simulation of new roads development > One-time versus multi-temporal simulation","what":"One-time simulation","title":"roads Package","text":"landings, costs, roads specified projectRoads, one-time road simulation performed returns list object holding projected roads related information. can repeated multiple times different road building scenarios simulation independent others.  independent one-time simulations appropriate landing set represents different development scenario (e.g. representing possible set landings time t=1), appropriate landings sets sequential (e.g. set 1 development time t=1, set 2 development time t=2, ). latter case, roads beginning time t union roads developed previous times steps.","code":"## project roads for landing sets 1 to 4, with independent one-time simulations oneTime_sim <- list() ## empty list  for (i in 1:4){   oneTime_sim <- c(oneTime_sim,                        roads::projectRoads(land.pnts[land.pnts$set==i,],                                               scen$cost.rast,                                               scen$cost.rast==0,                                               roadMethod='mst')$roads) } #> 0s detected in weightRaster raster, these will be considered as existing roads #> 0s detected in weightRaster raster, these will be considered as existing roads #> 0s detected in weightRaster raster, these will be considered as existing roads #> 0s detected in weightRaster raster, these will be considered as existing roads ## plot oldpar <- par(mfrow = c(2, 2), mar = par('mar')/2) for (i in 1:4){   oneTime_sim[[i]][!oneTime_sim[[i]]] <- NA    plot(scen$cost.rast, col = rastColours2,         main = paste0('Landings set ', i),        legend = FALSE)   plot(oneTime_sim[[i]], add = TRUE, col = \"grey50\", legend = FALSE)   plot(st_geometry(land.pnts[land.pnts$set == i, ]), add = TRUE,        pch = 21, cex = 1.5, bg = 'white') } ## raster representing the union of completely independent simulations for multiple sets oneTime_sim <- rast(oneTime_sim) independent <- any(oneTime_sim, na.rm = TRUE) ## set non-road to NA for display purposes independent[!independent] <- NA  ## plot  plot(scen$cost.rast, col = rastColours2,      main = 'Union of independent sim results',      legend = FALSE)  plot(independent, col = 'grey30', add = TRUE, legend = FALSE)  plot(st_geometry(land.pnts), add = TRUE, pch = 21, cex = 1.5, bg = 'white')"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"multi-temporal-simulation","dir":"Articles","previous_headings":"Simulation of new roads development > One-time versus multi-temporal simulation","what":"Multi-temporal simulation","title":"roads Package","text":"Multi-temporal (multiple time steps) road projections can obtained providing projectRoads list produced previous call projectRoads, new set landings. function uses sim list starting point, avoids computational cost reconstructing landscape graph. can implemented loop.","code":"## continuing on with demo scenario 1 ## landing sets 1 to 4 of this scenario as a raster stack land.stack <- scen$landings.stack[[1:4]]  # initialize sim list with first landings set multiTime_sim <- list(projectRoads(land.stack[[1]], scen$cost.rast,                                                 scen$road.line)) #> 0s detected in weightRaster raster, these will be considered as existing roads #> harvest raster values are all in 0,1. Using patches as landing areas # iterate over landings sets using the sim list from the previous run as input for (i in 2:nlyr(land.stack)) {   multiTime_sim <- c(     multiTime_sim,     list(projectRoads(sim =  multiTime_sim[[i-1]], landings = land.stack[[i]]))   )  } #> 0s detected in weightRaster raster, these will be considered as existing roads #> harvest raster values are all in 0,1. Using patches as landing areas #> 0s detected in weightRaster raster, these will be considered as existing roads #> harvest raster values are all in 0,1. Using patches as landing areas #> 0s detected in weightRaster raster, these will be considered as existing roads #> harvest raster values are all in 0,1. Using patches as landing areas par(mfrow = c(3, 2)) par(mar = par('mar')/2)   plot(scen$cost.rast, col = rastColours2, main = 'Roads at time t = 0',         legend = FALSE)   plot(scen$road.line, col = 'grey30', add = TRUE, legend = FALSE)    for (i in 1:length(multiTime_sim)){   plot(multiTime_sim[[i]]$weightRaster, col = rastColours2,         main = paste0('Roads at time t = ', i), legend = FALSE)   plot(multiTime_sim[[i]]$roads, col = 'grey30', add = TRUE, legend = FALSE)   plot(st_geometry(land.pnts[land.pnts$set == i, ]), add = TRUE, pch = 21,           cex = 1.5, bg = 'white')   if (i >= 2){     plot(st_geometry(land.pnts[land.pnts$set < i, ]), add = TRUE, pch = 1, cex = 1.5)     plot(st_geometry(land.pnts[land.pnts$set == i, ]), add = TRUE, pch = 21,           cex = 1.5, bg = 'white')   } }"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"multiple-landings-per-harvest-block","dir":"Articles","previous_headings":"Simulation of new roads development","what":"Multiple landings per harvest block","title":"roads Package","text":"Often harvest information available polygons showing cutover area point locations landings known. roads package includes getLandingsFromTarget function address situations. default getLandingsFromTarget use centroid polygon landing sampleType options include \"random\" \"regular\" selection multiple landing points within harvest blocks. \"random\" \"regular\" sampling, landingDens specifies expected number landings per unit area.","code":"harvPoly <- demoScen[[1]]$landings.poly  outCent <- getLandingsFromTarget(harvPoly) #> Warning: st_point_on_surface assumes attributes are constant over geometries plot(sf::st_geometry(harvPoly)) plot(outCent, col = \"red\", add = TRUE) # Get random sample with density 0.02 pts per unit area outRand <- getLandingsFromTarget(harvPoly, 0.02, sampleType = \"random\") #> you have asked for > 0.001 pts per m2 which is > 1000 pts per km2 and may take a long time prRand <- projectRoads(outRand, scen$cost.rast, scen$road.line) #> 0s detected in weightRaster raster, these will be considered as existing roads plot(scen$cost.rast, main = \"Random Landings in Harvest Blocks\",      col = rastColours2) plot(harvPoly, add = TRUE) plot(prRand$roads, add = TRUE,  col = \"grey50\") plot(outRand, col = \"red\", add = TRUE) # Get regular sample with density 0.02 pts per unit area outReg <- getLandingsFromTarget(harvPoly, 0.02, sampleType = \"regular\") #> you have asked for > 0.001 pts per m2 which is > 1000 pts per km2 and may take a long time prReg <- projectRoads(outReg, scen$cost.rast,scen$road.line) #> 0s detected in weightRaster raster, these will be considered as existing roads plot(scen$cost.rast, main = \"Regular Landings in Harvest Blocks\",      col = rastColours2) plot(harvPoly, add = TRUE) plot(prReg$roads, add = TRUE, col = \"grey50\") plot(outReg, col = \"red\", add = TRUE) # clean up  par(oldpar)"},{"path":"https://landscitech.github.io/roads/articles/roads-vignette.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"roads Package","text":"vignette partially copied Kyle Lochhead & Tyler Muhly’s 2018 CLUS example","code":""},{"path":"https://landscitech.github.io/roads/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sarah Endicott. Author, maintainer. Kyle Lochhead. Author. Josie Hughes. Author. Patrick Kirby. Author. Majesty Queen Right Canada represented Minister Environment. Copyright holder.            Copyright holder included functions buildSimList, getLandingsFromTarget, pathsToLines, plotRoads, projectRoads, rasterizeLine, rasterToLineSegments Province British Columbia. Copyright holder.            Copyright holder included functions getGraph, lcpList, mstList, shortestPaths, getClosestRoad, buildSnapRoads","code":""},{"path":"https://landscitech.github.io/roads/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Endicott S, Lochhead K, Hughes J, Kirby P (2024). roads: Road Network Projection. R package version 1.2.0,  https://landscitech.github.io/roads/, https://github.com/LandSciTech/roads.","code":"@Manual{,   title = {roads: Road Network Projection},   author = {Sarah Endicott and Kyle Lochhead and Josie Hughes and Patrick Kirby},   year = {2024},   note = {R package version 1.2.0,  https://landscitech.github.io/roads/},   url = {https://github.com/LandSciTech/roads}, }"},{"path":"https://landscitech.github.io/roads/index.html","id":"roads-","dir":"","previous_headings":"","what":"Road Network Projection","title":"Road Network Projection","text":"roads package offers iterative least cost path minimum spanning tree methods projecting forest road networks. methods connect set target points existing road network using igraph https://igraph.org identify least cost routes. cost constructing road segment adjacent pixels determined user supplied weightRaster weightFunction; options include average adjacent weightRaster values, function elevation differences adjacent cells penalizes steep grades. road network projection methods intended integration R workflows modelling frameworks used forecasting forest change, can applied multiple timesteps without rebuilding graph timestep.","code":""},{"path":"https://landscitech.github.io/roads/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Road Network Projection","text":"can install released version roads CRAN : development version GitHub :","code":"install.packages(\"roads\") # install.packages(\"devtools\") devtools::install_github(\"LandSciTech/roads\")"},{"path":"https://landscitech.github.io/roads/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Road Network Projection","text":"simulate development roads three inputs needed: current road network, locations connected road network (landings), weights raster together weighting function determines cost connect two raster cells road. Typically roads landings sf objects sp Spatial* objects weight raster.  default projectRoads uses iterative least cost paths algorithm (roadMethod = \"ilcp\") connect landing existing road lowest cost path, updating cost landing connected. minimum spanning tree method (roadMethod = \"mst\") also available. details see vignette vignette(\"roads-vignette\", package = \"roads\")","code":"library(roads) library(raster)  # data set installed with roads package demoScen <- prepExData(demoScen) scen <- demoScen[[1]]  prRoads <- projectRoads(landings = scen$landings.points,                          weightRaster = scen$cost.rast,                         roads = scen$road.line,                          plotRoads = TRUE)"},{"path":"https://landscitech.github.io/roads/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Road Network Projection","text":"Copyright (C) 2021 Majesty Queen Right Canada, represented Minister Environment Climate Change. Copyright 2018 Province British Columbia Licensed Apache License, Version 2.0 (“License”); may use file except compliance License. may obtain copy License https://www.apache.org/licenses/LICENSE-2.0 Unless required applicable law agreed writing, software distributed License distributed “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied. See License specific language governing permissions limitations License.","code":""},{"path":"https://landscitech.github.io/roads/reference/CLUSexample.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from the CLUS example — CLUSexample","title":"Data from the CLUS example — CLUSexample","text":"Kyle Lochhead Tyler Muhly's CLUS road simulation example. SpatRaster files created terra package must saved terra::wrap() need unwrapped used. prepExData() .","code":""},{"path":"https://landscitech.github.io/roads/reference/CLUSexample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from the CLUS example — CLUSexample","text":"","code":"data(CLUSexample)"},{"path":"https://landscitech.github.io/roads/reference/CLUSexample.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from the CLUS example — CLUSexample","text":"named list components: cost: PackedSpatRaster representing road building cost. landings: sf dataframe points representing landing locations. roads: PackedSpatRaster representing existing roads.","code":""},{"path":"https://landscitech.github.io/roads/reference/CLUSexample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from the CLUS example — CLUSexample","text":"","code":"CLUSexample #> $cost #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Projected CRS: NAD83 / Statistics Canada Lambert #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  prepExData(CLUSexample) #> $cost #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Statistics Canada Lambert (EPSG:3347)  #> source(s)   : memory #> name        :    lyr.1  #> min value   :  0.00000  #> max value   : 19.84622  #>  #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Projected CRS: NAD83 / Statistics Canada Lambert #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Statistics Canada Lambert (EPSG:3347)  #> source(s)   : memory #> name        : lyr.1  #> min value   : FALSE  #> max value   :  TRUE  #>"},{"path":"https://landscitech.github.io/roads/reference/dem_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Grade penalty example data — dem_example","title":"Grade penalty example data — dem_example","text":"list containing two rasters covering area near Revelstoke, British Columbia, Canada. ex_elev elevation data ex_wat proportion cell contains water. subsets data downloaded geodata package 30 arc seconds resolution.SpatRaster files created terra package must saved terra::wrap() need unwrapped used. prepExData() .","code":""},{"path":"https://landscitech.github.io/roads/reference/dem_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grade penalty example data — dem_example","text":"","code":"data(dem_example)"},{"path":"https://landscitech.github.io/roads/reference/dem_example.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Grade penalty example data — dem_example","text":"named list components: ex_elev: PackedSpatRaster elevation. ex_wat: PackedSpatRaster proportion water.","code":""},{"path":"https://landscitech.github.io/roads/reference/dem_example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Grade penalty example data — dem_example","text":"Elevation data primarily Shuttle Radar Topography Mission (SRTM), specifically hole-filled CGIAR-SRTM (90 m resolution) https://srtm.csi.cgiar.org/. Water data derived ESA WorldCover data set 0.3-seconds resolution. (License CC 4.0). See https://esa-worldcover.org/en information.","code":""},{"path":"https://landscitech.github.io/roads/reference/dem_example.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Grade penalty example data — dem_example","text":"Zanaga, D., Van De Kerchove, R., De Keersmaecker, W., Souverijns, N., Brockmann, C., Quast, R., Wevers, J., Grosu, ., Paccini, ., Vergnaud, S., Cartus, O., Santoro, M., Fritz, S., Georgieva, ., Lesiv, M., Carter, S., Herold, M., Li, Linlin, Tsendbazar, N.E., Ramoino, F., Arino, O., 2021. ESA WorldCover 10 m 2020 v100. doi:10.5281/zenodo.5571936.","code":""},{"path":"https://landscitech.github.io/roads/reference/dem_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grade penalty example data — dem_example","text":"","code":"dem_example #> $ex_elev #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $ex_wat #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  prepExData(dem_example) #> $ex_elev #> class       : SpatRaster  #> dimensions  : 173, 305, 1  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : -118.4917, -115.95, 49.40833, 50.85  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source(s)   : memory #> name        : CAN_elv_msk  #> min value   :         349  #> max value   :        3371  #>  #> $ex_wat #> class       : SpatRaster  #> dimensions  : 173, 305, 1  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : -118.4917, -115.95, 49.40833, 50.85  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source(s)   : memory #> name        : water  #> min value   :     0  #> max value   :     1  #>"},{"path":"https://landscitech.github.io/roads/reference/demoScen.html","id":null,"dir":"Reference","previous_headings":"","what":"Demonstration set of 10 input scenarios — demoScen","title":"Demonstration set of 10 input scenarios — demoScen","text":"demonstration set scenarios can used input projectRoads(). data contains SpatRaster objects must wrapped stored. unwrap use prepExData()","code":""},{"path":"https://landscitech.github.io/roads/reference/demoScen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Demonstration set of 10 input scenarios — demoScen","text":"","code":"data(demoScen)"},{"path":"https://landscitech.github.io/roads/reference/demoScen.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Demonstration set of 10 input scenarios — demoScen","text":"list sub-lists, sub-list representing input scenario. scenarios (sub-lists) contain following components: scen.number: integer value representing scenario number (generated scenarios numbered incrementally 1). road.rast: logical PackedSpatRaster representing existing roads.  TRUE existing road. FALSE existing road. road.line: sf object representing existing roads. cost.rast: PackedSpatRaster representing cost developing new roads given cell. landings.points: sf object representing landings sets landing locations within set. data frame includes field named 'set' contains integer values representing landings set point belongs landings.stack: PackedSpatRaster multiple layers representing landings landings sets. logical layer represents one landings set. Values TRUE landing given set. Values FALSE . landings.poly: sf object representing single set polygonal landings.","code":""},{"path":[]},{"path":"https://landscitech.github.io/roads/reference/demoScen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Demonstration set of 10 input scenarios — demoScen","text":"","code":"demoScen[[1]] #> $scen.number #> [1] 1 #>  #> $road.rast #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $road.line #> Simple feature collection with 4 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 99.5 ymax: 99.5 #> Projected CRS: NAD83 / Conus Albers #>   ID                       geometry #> 1  1 LINESTRING (0.5 59.5, 99.5 ... #> 2  2 LINESTRING (0.5 12.5, 99.5 ... #> 3  3 LINESTRING (78.5 99.5, 14.5... #> 4  4 LINESTRING (0.5 8.5, 99.5 1... #>  #> $cost.rast #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $landings.points #> Simple feature collection with 57 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 4.5 ymin: 4.5 xmax: 96.5 ymax: 99.5 #> Projected CRS: NAD83 / Conus Albers #> First 10 features: #>        lyr.1 set ID          geometry #> 1   9.854914   1  1 POINT (96.5 29.5) #> 2  10.736080   1  2 POINT (67.5 73.5) #> 3   8.799249   2  1 POINT (55.5 97.5) #> 4  10.610051   2  2 POINT (48.5 94.5) #> 5  10.067412   2  3 POINT (37.5 70.5) #> 6  11.688921   2  4 POINT (93.5 90.5) #> 7   9.823934   2  5 POINT (50.5 44.5) #> 8  12.055090   2  6 POINT (51.5 66.5) #> 9  10.630008   2  7 POINT (34.5 78.5) #> 10 11.007803   2  8   POINT (4.5 4.5) #>  #> $landings.stack #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $landings.poly #> Simple feature collection with 6 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 4.5 ymin: 29.5 xmax: 86.5 ymax: 93.5 #> Projected CRS: NAD83 / Conus Albers #>   ID                       geometry #> 1  1 POLYGON ((82.5 67.5, 82.5 6... #> 2  2 POLYGON ((48.5 93.5, 48.5 8... #> 3  3 POLYGON ((34.5 81.5, 34.5 7... #> 4  4 POLYGON ((4.5 47.5, 4.5 29.... #> 5  5 POLYGON ((66.5 42.5, 66.5 3... #> 6  6 POLYGON ((10.5 52.5, 10.5 4... #>  demoScen <- prepExData(demoScen) demoScen[[1]] #> $scen.number #> [1] 1 #>  #> $road.rast #> class       : SpatRaster  #> dimensions  : 100, 100, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 100, 0, 100  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Conus Albers (EPSG:5070)  #> source(s)   : memory #> name        : lyr.1  #> min value   : FALSE  #> max value   :  TRUE  #>  #> $road.line #> Simple feature collection with 4 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 99.5 ymax: 99.5 #> Projected CRS: NAD83 / Conus Albers #>   ID                       geometry #> 1  1 LINESTRING (0.5 59.5, 99.5 ... #> 2  2 LINESTRING (0.5 12.5, 99.5 ... #> 3  3 LINESTRING (78.5 99.5, 14.5... #> 4  4 LINESTRING (0.5 8.5, 99.5 1... #>  #> $cost.rast #> class       : SpatRaster  #> dimensions  : 100, 100, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 100, 0, 100  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Conus Albers (EPSG:5070)  #> source(s)   : memory #> name        :    lyr.1  #> min value   :  0.00000  #> max value   : 14.97291  #>  #> $landings.points #> Simple feature collection with 57 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 4.5 ymin: 4.5 xmax: 96.5 ymax: 99.5 #> Projected CRS: NAD83 / Conus Albers #> First 10 features: #>        lyr.1 set ID          geometry #> 1   9.854914   1  1 POINT (96.5 29.5) #> 2  10.736080   1  2 POINT (67.5 73.5) #> 3   8.799249   2  1 POINT (55.5 97.5) #> 4  10.610051   2  2 POINT (48.5 94.5) #> 5  10.067412   2  3 POINT (37.5 70.5) #> 6  11.688921   2  4 POINT (93.5 90.5) #> 7   9.823934   2  5 POINT (50.5 44.5) #> 8  12.055090   2  6 POINT (51.5 66.5) #> 9  10.630008   2  7 POINT (34.5 78.5) #> 10 11.007803   2  8   POINT (4.5 4.5) #>  #> $landings.stack #> class       : SpatRaster  #> dimensions  : 100, 100, 10  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 100, 0, 100  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Conus Albers (EPSG:5070)  #> source(s)   : memory #> names       : lyr.1, lyr.1, lyr.1, lyr.1, lyr.1, lyr.1, ...  #> min values  : FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, ...  #> max values  :  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE, ...  #>  #> $landings.poly #> Simple feature collection with 6 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 4.5 ymin: 29.5 xmax: 86.5 ymax: 93.5 #> Projected CRS: NAD83 / Conus Albers #>   ID                       geometry #> 1  1 POLYGON ((82.5 67.5, 82.5 6... #> 2  2 POLYGON ((48.5 93.5, 48.5 8... #> 3  3 POLYGON ((34.5 81.5, 34.5 7... #> 4  4 POLYGON ((4.5 47.5, 4.5 29.... #> 5  5 POLYGON ((66.5 42.5, 66.5 3... #> 6  6 POLYGON ((10.5 52.5, 10.5 4... #>"},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":null,"dir":"Reference","previous_headings":"","what":"Moving window approach to get distance from source — getDistFromSource","title":"Moving window approach to get distance from source — getDistFromSource","text":"function deprecated please use terra::distance(). Note need set target = 0 get distances cells zero cells non-zero.","code":""},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moving window approach to get distance from source — getDistFromSource","text":"","code":"getDistFromSource(src, maxDist, kwidth = 3, method = \"terra\", override = FALSE)"},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moving window approach to get distance from source — getDistFromSource","text":"src SpatRaster RasterLayer, values > 0 treated source locations. NA values treated 0s. maxDist Numeric, maximum distance calculated units CRS. kwidth Integer, \"pfocal\" \"terra\" methods width moving window. \"pfocal2\" method aggregation factor. method Character, method use, currently \"terra\" supported CRAN version, \"pfocal\" \"pfocal2\" available development version. See details. override Logical, TRUE use old deprecated function.","code":""},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moving window approach to get distance from source — getDistFromSource","text":"SpatRaster","code":""},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Moving window approach to get distance from source — getDistFromSource","text":"function provides three different methods calculating distance points landscape \"source\" locations. computationally intensive process function arguments can used balance tradeoffs speed accuracy. Note pfocal versions available development version package. \"terra\" \"pfocal\" methods use iterative moving window approach assign cell distance based number times moving window repeated included. means moving window function run many times small window relative size raster. maxDist argument determines maximum distance calculated affects number iterations moving window needed. kwidth radius moving window number cells, larger values reducing number iterations needed also reducing granularity distances produced. resulting distances increments kwidth resolution raster. total number iterations maxDist/ kwidth * resolution. difference methods underlying package used moving window. terra package methods handling large rasters writing disk, pfocal package requires raster can held memory matrix. third method \"pfocal2\" uses global moving window calculate distance source. means moving window needs applied window size can large. case maxDist determines total size window. kwidth can used reduce number cells included moving window aggregating source raster factor kwidth. increase speed computation produce results artefacts larger grid may less accurate since output raster disaggregated using bilinear interpolation.","code":""},{"path":"https://landscitech.github.io/roads/reference/getDistFromSource.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Moving window approach to get distance from source — getDistFromSource","text":"","code":"CLUSexample <-  prepExData(CLUSexample) # Deprecated # getDistFromSource(CLUSexample$roads, 5, 2)  # Use terra::distance instead terra::distance(CLUSexample$roads, target = 0) #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Statistics Canada Lambert (EPSG:3347)  #> source(s)   : memory #> name        : lyr.1  #> min value   :     0  #> max value   :     4   # \\donttest{  library(sf) #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE  library(terra) #> terra 1.7.78  #make example roads from scratch rds <- data.frame(x = 1:1000/100, y = cos(1:1000/100)) %>%   st_as_sf(coords = c(\"x\", \"y\")) %>%   st_union() %>%   st_cast(\"LINESTRING\")  rds_rast <- rasterize(vect(rds),                       rast(nrows = 50, ncols = 50,                            xmin = 0, xmax = 10,                            ymin = -5, ymax = 5),                       touches = TRUE)  terra::distance(rds_rast) #>  |---------|---------|---------|---------| =========================================                                            #> class       : SpatRaster  #> dimensions  : 50, 50, 1  (nrow, ncol, nlyr) #> resolution  : 0.2, 0.2  (x, y) #> extent      : 0, 10, -5, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        :    layer  #> min value   :      0.0  #> max value   : 549661.6   # or straight from the line terra::distance(rds_rast, terra::vect(rds %>% st_set_crs(st_crs(rds_rast)))) #>  |---------|---------|---------|---------| =========================================                                            #> class       : SpatRaster  #> dimensions  : 50, 50, 1  (nrow, ncol, nlyr) #> resolution  : 0.2, 0.2  (x, y) #> extent      : 0, 10, -5, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        :       layer  #> min value   :    453.3088  #> max value   : 562906.4665  # }"},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":null,"dir":"Reference","previous_headings":"","what":"Get landing target points within harvest blocks — getLandingsFromTarget","title":"Get landing target points within harvest blocks — getLandingsFromTarget","text":"Generate landing points inside polygons representing harvested area. three different sampling types available: \"centroid\" (default) returns centroid point inside polygon centroid (see sf::st_point_on_surface()); \"random\" returns random sample given landingDens see (sf::st_sample()); \"regular\" returns points regular grid cell size sqrt(1/landingDens) intersect polygon, centroid grid points fall within polygon.","code":""},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get landing target points within harvest blocks — getLandingsFromTarget","text":"","code":"getLandingsFromTarget(harvest, landingDens = NULL, sampleType = \"centroid\")"},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get landing target points within harvest blocks — getLandingsFromTarget","text":"harvest sf, SpatialPolygons, SpatRaster RasterLayer object harvested areas. raster values outside 0,1, values assumed harvest block IDs. raster values 0,1 assumed binary raster terra::patches used identify harvest blocks. landingDens number landings per unit area. units CRS harvest. Note 0.001 points per m2 > 1000 points per km2 number usually small projected CRS. sampleType character. \"centroid\" (default), \"regular\" \"random\". \"centroid\" returns one landing per harvest block, guaranteed harvest block sf objects rasters. \"regular\" returns points grid density landingDens overlap harvested areas. \"random\" returns random set points polygon determined area polygon landingDens. harvest raster set landings always includes centroid ensure least one landing harvest block.","code":""},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get landing target points within harvest blocks — getLandingsFromTarget","text":"sf simple feature collection ID column POINT geometry","code":""},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get landing target points within harvest blocks — getLandingsFromTarget","text":"Note landingDens points per unit area unit area determined CRS. projected CRS likely small number .e. < 0.001.","code":""},{"path":"https://landscitech.github.io/roads/reference/getLandingsFromTarget.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get landing target points within harvest blocks — getLandingsFromTarget","text":"","code":"doPlots <- interactive() demoScen <- prepExData(demoScen)  polys <- demoScen[[1]]$landings.poly[1:2,]  # Get centroid outCent <- getLandingsFromTarget(polys) #> Warning: st_point_on_surface assumes attributes are constant over geometries  if(doPlots){   plot(sf::st_geometry(polys))   plot(outCent, col = \"red\", add = TRUE) }  # Get random sample with density 0.1 points per unit area outRand <- getLandingsFromTarget(polys, 0.1, sampleType = \"random\") #> you have asked for > 0.001 pts per m2 which is > 1000 pts per km2 and may take a long time  if(doPlots){   plot(sf::st_geometry(polys))   plot(outRand, col = \"red\", add = TRUE) }  # Get regular sample with density 0.1 points per unit area outReg <- getLandingsFromTarget(polys, 0.1, sampleType = \"regular\") #> you have asked for > 0.001 pts per m2 which is > 1000 pts per km2 and may take a long time  if(doPlots){   plot(sf::st_geometry(polys))   plot(outReg, col = \"red\", add = TRUE) }"},{"path":"https://landscitech.github.io/roads/reference/gradePenaltyFn.html","id":null,"dir":"Reference","previous_headings":"","what":"Grade penalty edge weight function — gradePenaltyFn","title":"Grade penalty edge weight function — gradePenaltyFn","text":"Method calculating weight edge two nodes value input raster nodes (x1 x2), designed single DEM input. method assumes input weightRaster : NA indicates road built Negative values costs crossing streams barriers crossable expensive. Edges link barrier penalty (negative value) nodes assigned largest barrier penalty weight. Zero values assumed existing roads. values interpreted elevation units raster map (difference two cells equal map resolution can interpreted 100% grade) simplified version grade penalty approach taken Anderson Nelson (2004): approach distinguish adverse favourable grades. Default construction cost values BC interior appraisal manual. approach ignores (unknown) grade penalties beside roads barriers order avoid increased memory computational burden associated multiple input rasters.","code":""},{"path":"https://landscitech.github.io/roads/reference/gradePenaltyFn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grade penalty edge weight function — gradePenaltyFn","text":"","code":"gradePenaltyFn(   x1,   x2,   hdistance,   baseCost = 16178,   limit = 20,   penalty = 504,   limitWeight = NA )"},{"path":"https://landscitech.github.io/roads/reference/gradePenaltyFn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grade penalty edge weight function — gradePenaltyFn","text":"x1, x2 Number. Value input raster two nodes. hdistance Number. Horizontal distance nodes. hdistance, x1, x2 units. baseCost Number. Construction cost 0% grade road per km. limit Number. Maximum grade (%) roads can built. penalty Number. Cost increase (per km) associated additional % increase road grade. limitWeight Number. Value assigned edges exceed grade limit. Try setting high (NA) value encountering problems disconnected graphs.","code":""},{"path":"https://landscitech.github.io/roads/reference/gradePenaltyFn.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Grade penalty edge weight function — gradePenaltyFn","text":"Anderson AE, Nelson J (2004) Projecting vector-based road networks shortest path algorithm. Canadian Journal Forest Research 34:1444–1457. https://doi.org/10.1139/x04-030","code":""},{"path":"https://landscitech.github.io/roads/reference/gradePenaltyFn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grade penalty edge weight function — gradePenaltyFn","text":"","code":"gradePenaltyFn(0.5,0.51,1) #> [1] 16682 gradePenaltyFn(0.5,0.65,1) #> [1] 23738 # grade > 20% so NA gradePenaltyFn(0.5,0.75,1) #> [1] NA"},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot projected roads — plotRoads","title":"Plot projected roads — plotRoads","text":"Plot results projectRoads()","code":""},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot projected roads — plotRoads","text":"","code":"plotRoads(sim, mainTitle, subTitle = paste0(\"Method: \", sim$roadMethod), ...)"},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot projected roads — plotRoads","text":"sim sim list result projectRoads mainTitle character. title plot subTitle character. sub title plot, default roadMethod used ... arguments passed raster plot call weightRaster","code":""},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot projected roads — plotRoads","text":"Creates plot using base graphics","code":""},{"path":"https://landscitech.github.io/roads/reference/plotRoads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot projected roads — plotRoads","text":"","code":"CLUSexample <- prepExData(CLUSexample) prRes <- projectRoads(CLUSexample$landings, CLUSexample$cost, CLUSexample$roads) #> 0s detected in weightRaster raster, these will be considered as existing roads if(interactive()){   plotRoads(prRes, \"Title\") }"},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare example data — prepExData","title":"Prepare example data — prepExData","text":"Prepare example data included package contain wrapped terra objects. applies terra::unwrap() recursively list provided PackedSpatRasters converted SpatRasters.","code":""},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare example data — prepExData","text":"","code":"prepExData(x)"},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare example data — prepExData","text":"x list. Contains elements packed SpatRasters.","code":""},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare example data — prepExData","text":"list unwrapped SpatRasters","code":""},{"path":"https://landscitech.github.io/roads/reference/prepExData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare example data — prepExData","text":"","code":"CLUSexample #> $cost #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Projected CRS: NAD83 / Statistics Canada Lambert #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\" #>  prepExData(CLUSexample) #> $cost #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Statistics Canada Lambert (EPSG:3347)  #> source(s)   : memory #> name        :    lyr.1  #> min value   :  0.00000  #> max value   : 19.84622  #>  #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Projected CRS: NAD83 / Statistics Canada Lambert #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Statistics Canada Lambert (EPSG:3347)  #> source(s)   : memory #> name        : lyr.1  #> min value   : FALSE  #> max value   :  TRUE  #>"},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":null,"dir":"Reference","previous_headings":"","what":"Project road network — projectRoads","title":"Project road network — projectRoads","text":"Project road network links target landings existing roads. methods except \"snap\", weightRaster weightFunction together determine cost build road two adjacent raster cells.","code":""},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project road network — projectRoads","text":"","code":"projectRoads(   landings = NULL,   weightRaster = NULL,   roads = NULL,   roadMethod = \"ilcp\",   plotRoads = FALSE,   mainTitle = \"\",   neighbourhood = \"octagon\",   weightFunction = simpleCostFn,   sim = NULL,   roadsOut = NULL,   roadsInWeight = TRUE,   ordering = \"closest\",   roadsConnected = FALSE,   ... )  # S4 method for ANY,ANY,ANY,ANY,ANY,ANY,ANY,ANY,missing projectRoads(   landings = NULL,   weightRaster = NULL,   roads = NULL,   roadMethod = \"ilcp\",   plotRoads = FALSE,   mainTitle = \"\",   neighbourhood = \"octagon\",   weightFunction = simpleCostFn,   sim = NULL,   roadsOut = NULL,   roadsInWeight = TRUE,   ordering = \"closest\",   roadsConnected = FALSE,   ... )  # S4 method for ANY,ANY,ANY,ANY,ANY,ANY,ANY,ANY,list projectRoads(   landings = NULL,   weightRaster = NULL,   roads = NULL,   roadMethod = \"ilcp\",   plotRoads = FALSE,   mainTitle = \"\",   neighbourhood = \"octagon\",   weightFunction = simpleCostFn,   sim = NULL,   roadsOut = NULL,   roadsInWeight = TRUE,   ordering = \"closest\",   roadsConnected = FALSE,   ... )"},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project road network — projectRoads","text":"landings sf polygons points, RasterLayer, SpatialPolygons*, SpatialPoints*, matrix. Contains features connected road network. Matrix contain columns x, y coordinates, columns ignored. Polygon raster inputs processed getLandingsFromTarget() get centroid harvest blocks. weightRaster SpatRaster RasterLayer. weightRaster weightFunction together determine cost build road two adjacent raster cells. default weightFunction = simpleCostFn, weightRaster specify cost construction across raster cell. value cells contain existing roads set 0; set roadsInWeight = FALSE adjust cost existing roads. use alternative grade penalty method, set weightFunction = gradePenaltyFn, provide weightRaster : NA indicates road built Negative values costs crossing streams barriers crossable expensive. Zero values existing roads. values interpreted elevation units raster map (difference two cells equal map resolution can interpreted 100% grade). roads sf lines, SpatialLines*, RasterLayer, SpatRaster. existing road network. roadMethod Character. Options \"ilcp\", \"mst\", \"lcp\", \"snap\". See Details . plotRoads Boolean. resulting road network plotted. Default FALSE. mainTitle Character. title plot. neighbourhood Character. \"rook\", \"queen\", \"octagon\". Determines cells considered adjacent. default \"octagon\" option modified version queen's 8 cell neighbourhood diagonal weights multiplied 2^0.5. weightFunction function. Method calculating weight edge two nodes value weightRaster nodes (x1 x2). default simpleCostFn mean. alternative, gradePenaltyFn, sets edge weights function difference adjacent weightRaster cells penalize steep grades. Users supplying weightFunction note must symmetric, meaning value returned depend ordering x1 x2. weightFunction must include arguments x1, x2 .... sim list. Returned previous iteration projectRoads. weightRaster, roads, roadMethod ignored sim list provided. roadsOut Character. Either \"raster\", \"sf\" NULL. \"raster\" roads returned SpatRaster sim list. \"sf\" roads returned sf object contain lines roads input sf lines geometry collection lines points roads input raster. points geometry collection represent existing roads new roads created lines. NULL (default) returned roads sf input sf Spatial* SpatRaster input raster. roadsInWeight Logical. TRUE (default) value existing roads weightRaster assumed 0. FALSE cells weightRaster contain existing roads set 0. ordering character. order landings processed roadMethod = \"ilcp\". Options \"closest\" (default) landings closest existing roads accessed first, \"none\" landings accessed order provided . roadsConnected Logical. roads fully connected? TRUE roadMethod = \"mst\" MST graph can simplified projection faster. Default FALSE. ... Optional additional arguments weightFunction.","code":""},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project road network — projectRoads","text":"list components: roads: projected road network, including new input roads. weightRaster: updated weightRaster new old roads value 0. roadMethod: road simulation method used. landings: landings used simulation. g: graph describes cost paths cell updated weightRaster. Edges vertices connected new roads weight 0. g can used avoid cost rebuilding graph simulation multiple time steps.","code":""},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project road network — projectRoads","text":"Four road network projection methods : \"lcp\": Least Cost Path method connects landing closest road least cost path, without reference landings. \"ilcp\": Iterative Least Cost Path method iteratively connects landing closest road least cost path, path successive landing can include roads constructed access previous landings. sequence landings determined ordering \"closest\" default. alternative \"none\" option processes landings order supplied user. \"mst\": Minimum Spanning Tree method connects landings existing road minimum spanning tree require users specify order landings processed. \"snap\": Connects landing closest (Euclidean distance) road without, reference weights landings.","code":""},{"path":"https://landscitech.github.io/roads/reference/projectRoads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project road network — projectRoads","text":"","code":"CLUSexample <- prepExData(CLUSexample) doPlots <- interactive()  projectRoads(CLUSexample$landings, CLUSexample$cost, CLUSexample$roads,              \"lcp\", plotRoads = doPlots, mainTitle = \"CLUSexample\") #> 0s detected in weightRaster raster, these will be considered as existing roads #> $landings #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.5 ymin: 0.5 xmax: 4.5 ymax: 2.5 #> Projected CRS: NAD83 / Statistics Canada Lambert #>          geometry #> 1 POINT (0.5 2.5) #> 2 POINT (2.5 2.5) #> 3 POINT (1.5 0.5) #> 4 POINT (4.5 0.5) #>  #> $roads #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Statistics Canada Lambert (EPSG:3347)  #> source(s)   : memory #> name        : lyr.1  #> min value   : FALSE  #> max value   :  TRUE  #>  #> $g #> IGRAPH 24dc367 U-W- 25 72 --  #> + attr: weight (e/n) #> + edges from 24dc367: #>  [1]  1-- 2  1-- 6  1-- 7  2-- 3  2-- 6  2-- 7  2-- 8  3-- 4  3-- 7  3-- 8 #> [11]  3-- 9  4-- 5  4-- 8  4-- 9  4--10  5-- 9  5--10  6-- 7  6--11  6--12 #> [21]  7-- 8  7--11  7--12  7--13  8-- 9  8--12  8--13  8--14  9--10  9--13 #> [31]  9--14  9--15 10--14 10--15 11--12 11--16 11--17 12--13 12--16 12--17 #> [41] 12--18 13--14 13--17 13--18 13--19 14--15 14--18 14--19 14--20 15--19 #> [51] 15--20 16--17 16--21 16--22 17--18 17--21 17--22 17--23 18--19 18--22 #> [61] 18--23 18--24 19--20 19--23 19--24 19--25 20--24 20--25 21--22 22--23 #> [71] 23--24 24--25 #>  #> $weightRaster #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Statistics Canada Lambert (EPSG:3347)  #> source(s)   : memory #> name        :    lyr.1  #> min value   :  0.00000  #> max value   : 19.84622  #>  #> $roadMethod #> [1] \"lcp\" #>    # More realistic examples that take longer to run # \\donttest{  demoScen <- prepExData(demoScen)  ### using:  scenario 1 / sf landings / iterative least-cost path (\"ilcp\") # demo scenario 1 scen <- demoScen[[1]]  # landing set 1 of scenario 1: land.pnts <- scen$landings.points[scen$landings.points$set==1,]  prRes <- projectRoads(land.pnts, scen$cost.rast, scen$road.line, \"ilcp\",                          plotRoads = doPlots, mainTitle = \"Scen 1: SPDF-LCP\") #> 0s detected in weightRaster raster, these will be considered as existing roads  ### using: scenario 1 / `SpatRaster` landings / minimum spanning tree (\"mst\") # demo scenario 1 scen <- demoScen[[1]]  # the RasterLayer version of landing set 1 of scenario 1: land.rLyr <- scen$landings.stack[[1]]  prRes <- projectRoads(land.rLyr, scen$cost.rast, scen$road.line, \"mst\",                          plotRoads = doPlots, mainTitle = \"Scen 1: Raster-MST\") #> 0s detected in weightRaster raster, these will be considered as existing roads #> harvest raster values are all in 0,1. Using patches as landing areas   ### using: scenario 2 / matrix landings raster roads / snapping (\"snap\") # demo scenario 2 scen <- demoScen[[2]]  # landing set 5 of scenario 2, as matrix: land.mat  <- scen$landings.points[scen$landings.points$set==5,] |>   sf::st_coordinates()  prRes <- projectRoads(land.mat, scen$cost.rast, scen$road.rast, \"snap\",                       plotRoads = doPlots, mainTitle = \"Scen 2: Matrix-Snap\") #> 0s detected in weightRaster raster, these will be considered as existing roads #> CRS of landings supplied as a matrix is assumed to match the weightRaster  ## using scenario 7 / Polygon landings raster / minimum spanning tree # demo scenario 7 scen <- demoScen[[7]] # rasterize polygonal landings of demo scenario 7: land.polyR <- terra::rasterize(scen$landings.poly, scen$cost.rast)  prRes <- projectRoads(land.polyR, scen$cost.rast, scen$road.rast, \"mst\",                          plotRoads = doPlots, mainTitle = \"Scen 7: PolyRast-MST\") #> 0s detected in weightRaster raster, these will be considered as existing roads #> harvest raster values are all in 0,1. Using patches as landing areas # }"},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert raster to lines — rasterToLineSegments","title":"Convert raster to lines — rasterToLineSegments","text":"Converts rasters represent lines sf object.","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert raster to lines — rasterToLineSegments","text":"","code":"rasterToLineSegments(rast, method = \"mst\")"},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert raster to lines — rasterToLineSegments","text":"rast SpatRaster. Raster representing lines values > 0 assumed lines method character. Method building lines. Options \"mst\" (default) \"nearest\". See Details .","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert raster to lines — rasterToLineSegments","text":"sf simple feature collection","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert raster to lines — rasterToLineSegments","text":"method = \"nearest\" raster first converted points lines drawn nearest points. two different ways connect points distance kept can cause doubled lines. USE CAUTION. method = \"mst\" converts raster points, reclassifies raster roads 0 cells 1 uses projectRoads connect points minimum spanning tree. always connect raster cells slower double lines often. Neither method likely work large rasters","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterToLineSegments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert raster to lines — rasterToLineSegments","text":"","code":"CLUSexample <- prepExData(CLUSexample) # works well for very simple roads roadLine1 <- rasterToLineSegments(CLUSexample$roads) #> Warning: No 0s detected in weightRaster. If existing roads have not been included in the weightRaster set roadsInWeight = FALSE to have them burned in  # longer running more realistic examples # \\donttest{ demoScen <- prepExData(demoScen) # mst method works well in this case roadLine2 <- rasterToLineSegments(demoScen[[1]]$road.rast) #> Warning: No 0s detected in weightRaster. If existing roads have not been included in the weightRaster set roadsInWeight = FALSE to have them burned in  # nearest method has doubled line where the two roads meet roadLine3 <- rasterToLineSegments(demoScen[[1]]$road.rast, method = \"nearest\")  # The mst method can also produce odd results in some cases roadLine4 <- rasterToLineSegments(demoScen[[4]]$road.rast) #> Warning: No 0s detected in weightRaster. If existing roads have not been included in the weightRaster set roadsInWeight = FALSE to have them burned in  # }"},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":null,"dir":"Reference","previous_headings":"","what":"Faster rasterize for lines — rasterizeLine","title":"Faster rasterize for lines — rasterizeLine","text":"Rasterize line using stars fasterize work lines rasterize slow. Deprecated use terra::rasterize","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Faster rasterize for lines — rasterizeLine","text":"","code":"rasterizeLine(sfLine, rast, value)"},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Faster rasterize for lines — rasterizeLine","text":"sfLine sf object rasterized rast raster use template output raster value number value give background ie 0 NA","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Faster rasterize for lines — rasterizeLine","text":"RasterLayer value cells touch line row index line sf","code":""},{"path":"https://landscitech.github.io/roads/reference/rasterizeLine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Faster rasterize for lines — rasterizeLine","text":"","code":"CLUSexample <- prepExData(CLUSexample) roadsLine <- sf::st_sf(geometry = sf::st_sfc(sf::st_linestring( matrix(c(0.5, 4.5, 4.5, 4.51),        ncol = 2, byrow = TRUE)  )))  # Deprecated rasterizeLine(roadsLine, CLUSexample$cost, 0)    # Use terra::rasterize terra::rasterize(roadsLine, CLUSexample$cost, background = 0) #> class       : SpatRaster  #> dimensions  : 5, 5, 1  (nrow, ncol, nlyr) #> resolution  : 1, 1  (x, y) #> extent      : 0, 5, 0, 5  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Statistics Canada Lambert (EPSG:3347)  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1"},{"path":"https://landscitech.github.io/roads/reference/roads-package.html","id":null,"dir":"Reference","previous_headings":"","what":"roads: Road Network Projection — roads-package","title":"roads: Road Network Projection — roads-package","text":"Iterative least cost path minimum spanning tree methods projecting forest road networks. methods connect set target points existing road network using igraph https://igraph.org identify least cost routes. cost constructing road segment adjacent pixels determined user supplied `weightRaster` `weightFunction`; options include average adjacent `weightRaster` values, function elevation differences adjacent cells penalizes steep grades. road network projection methods intended integration R workflows modelling frameworks used forecasting forest change, can applied multiple timesteps without rebuilding graph timestep.","code":""},{"path":[]},{"path":"https://landscitech.github.io/roads/reference/roads-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"roads: Road Network Projection — roads-package","text":"Maintainer: Sarah Endicott sarah.endicott@ec.gc.ca (ORCID) Authors: Kyle Lochhead Kyle.Lochhead@gov.bc.ca Josie Hughes josie.hughes@ec.gc.ca Patrick Kirby contributors: Majesty Queen Right Canada represented Minister Environment (Copyright holder included functions buildSimList, getLandingsFromTarget, pathsToLines, plotRoads, projectRoads, rasterizeLine, rasterToLineSegments) [copyright holder] Province British Columbia (Copyright holder included functions getGraph, lcpList, mstList, shortestPaths, getClosestRoad, buildSnapRoads) [copyright holder]","code":""},{"path":"https://landscitech.github.io/roads/reference/simpleCostFn.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple cost edge weight function — simpleCostFn","title":"Simple cost edge weight function — simpleCostFn","text":"Calculates weight edge two nodes mean value input cost raster nodes (x1 x2).","code":""},{"path":"https://landscitech.github.io/roads/reference/simpleCostFn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple cost edge weight function — simpleCostFn","text":"","code":"simpleCostFn(x1, x2, hdistance)"},{"path":"https://landscitech.github.io/roads/reference/simpleCostFn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple cost edge weight function — simpleCostFn","text":"x1, x2 Number. Value input cost raster two nodes. hdistance Number. Horizontal distance nodes - penalizing longer diagonal edges.","code":""},{"path":"https://landscitech.github.io/roads/reference/simpleCostFn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple cost edge weight function — simpleCostFn","text":"","code":"simpleCostFn(0.5,0.7,1) #> [1] 0.6"},{"path":"https://landscitech.github.io/roads/news/index.html","id":"roads-120","dir":"Changelog","previous_headings":"","what":"roads 1.2.0","title":"roads 1.2.0","text":"Change dynamic least cost paths (DLCP) iterative least cost paths (ILCP) throughout Change default roadMethod \"ilcp\" projectRoads Add ability use custom weightFunction add weightFunction gradePenaltyFn determines grade two cells Change argument name cost weightRaster since longer represents cost surface can now inputs weightFunction. Also change roadsInCost roadsInWeight. returned roads longer unioned together. Deprecate getDistFromSource use terra::distance instead. Fix bug getLandingsFromTarget change patches used 0,1 rasters ids used otherwise using terra::.polygons make faster.","code":""},{"path":"https://landscitech.github.io/roads/news/index.html","id":"roads-111","dir":"Changelog","previous_headings":"","what":"roads 1.1.1","title":"roads 1.1.1","text":"CRAN release: 2023-06-24 Fix issue updates terra causing roads break process removed raster sp dependencies converted example data terra sf formats. requires new function prepExData unwrap terra objects needed wrapped storage","code":""},{"path":"https://landscitech.github.io/roads/news/index.html","id":"roads-110","dir":"Changelog","previous_headings":"","what":"roads 1.1.0","title":"roads 1.1.0","text":"CRAN release: 2023-02-02 converted using terra throughout package. raster objects still accepted converted terra formats. Added getDistFromSource function use moving windows quickly get raster distance nearest source (e.g road). remove SpaDES.tools dependency archived CRAN equivalent method terra now. returned cost raster now includes projected roads cost 0. makes easier loop additional road building time change previous version input cost surface returned.","code":""},{"path":"https://landscitech.github.io/roads/news/index.html","id":"roads-100","dir":"Changelog","previous_headings":"","what":"roads 1.0.0","title":"roads 1.0.0","text":"CRAN release: 2022-06-22 Added NEWS.md file track changes package.","code":""}]
