---
title: "projectRoads"
author: "Modified and parially copied from Kyle Lochhead & Tyler Muhly's 2018 CLUS example"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(roads)
library(raster)
library(colorspace)
```

# Introduction

This vignette provides a tutorial on the use of the `roads` package for the spatial simulation of future roads development under a given resource development scenario.  This tutorial, which borrows heavily from a demonstration written by Kyle Lochhead and Tyler Muhly in 2018, will focus primarily on the `projectRoads` method of the `roads` package, as it is responsible for performing the simulation. Example datasets from Kyle Lochhead and Tyler Muhly's **CLUS road simulation example** will be again used within this documentation.

In the context of this package, resource development scenarios are represented by three components:

1. a spatial, gridded cost layer covering the entire landscape, wherein each cell represents the cost of new road developement through it.
2. a spatial, gridded representation of the existing road network within the landscape, and
3. a set of locations, refered to as "**landings**", where new resource development is to take place.

The nature of how the landings are defined in the resource development scenario dictates whether the new roads development simulation will be a one-time or multi-temporal simulation.

Given an input resource development scenario, the `projectRoads` method will simulate new roads between the existing road network and the landings using one of three user-specific simulation methods (not to be confused with R language methods):

1. the **snapping** simulation method,
2. the **least-cost path (LCP)** simulation method, or
3. the **minimum spanning tree (MST)** simulation method.


# Resource development scenario

## 1. Cost layer

The cost of new roads development within a landscape is specified to the `projectRoads` method in the form of a single, numeric [`RasterLayer`](https://www.rdocumentation.org/packages/raster/versions/2.9-5/topics/Raster-class) {[`raster`](https://cran.r-project.org/web/packages/raster/index.html)} object.  Each cell of this raster represents the cost of new road developement (the definition of which is up to the user) through it.  Following this, the total cost of the development of a new road segment is considered to be the sum of the cost raster cells that it traverses.

* The traversal cost of existing road segments is assumed to be zero.
* The extent of the landscape of interest is assumed to match the extent of the specified cost raster layer.
* The coordinate reference system (CRS) of this raster does not need to be specified, so long as all other resource development scenario input data-sets match.  
* While the cell size (or resolution) of this cost raster is up the user, it is important to remember that the a unit area of road is assumed to take up an entire cell.

The simple cost raster used in the CLUS roads simulation example is included within the `CLUSexample` data-set of this package.

```{r, include = FALSE}
knitr::opts_chunk$set(fig.width=5,fig.height=4.85)
```

```{r, fig.show='hold'}
library(roads)
library(raster)
library(colorspace)
## colours for displaying cost raster (optional; could just use default)
rastColours <- c('grey50',diverge_hcl(20,h=c(130,43),c=100,l=c(70,90)))
## get the cost raster from the CLUSexmaple data-set and plot
costRaster <- roads::CLUSexample$cost
plot(costRaster,col=rastColours,main='Cost')
```

Notice that the top row of the raster has a cost of zero.  This row is where, in this scenario, an existing road traverses the landscape.

## 2. Existing road network layer

Since, in the context of this package, new roads simulation involves connecting landings to an existing roads network, the state of the existing roads network must be specified to the `projectRoads` method.  This specification is made in the form of a binary or logical raster layer, with a value of `1` or `TRUE` representing cells covered by the existing roads network, and `0` or `FALSE` representing cells that are not.

* The traversal cost of existing road segments is assumed to be zero.
* This raster is expected to match the input cost raster layer in terms of cell size (or resolution), CRS, and extent.  If unsure, the [raster::compareRaster](https://www.rdocumentation.org/packages/raster/versions/2.9-5/topics/compareRaster) function can be used to compare the the cost raster layer with the existing roads raster layer.  It will return TRUE if they are a valid match.

The existing roads network used in the CLUS roads simulation example is included within the `CLUSexample` data-set of this package.  Alternatively, it could be extracted from cost raster layer by isolating cells where the cost is zero.

```{r, include = FALSE}
knitr::opts_chunk$set(fig.width=7,fig.height=3.93)
```

```{r, fig.show='hold'}
## existing roads network raster from the CLUSexample data-set
existingRoadsRast <- roads::CLUSexample$roads
## alternatively, existing roads network raster from the cost raster layer, where cells are zero
alt_existingRoadsRast <- costRaster==0
## they are the same?
raster::compareRaster(existingRoadsRast,alt_existingRoadsRast,
                      values=TRUE,extent=TRUE,res=TRUE,crs=TRUE)
## the existing roads raster matches the cost raster in terms of extent, resolution, and CRS?
raster::compareRaster(existingRoadsRast,costRaster,
                      values=FALSE,extent=TRUE,res=TRUE,crs=TRUE)
## plot cost ratser (left) and existing roads raster (right)
par(mfrow=c(1,2))
plot(costRaster,col=rastColours,main='Cost')
plot(existingRoadsRast,col=c('grey80','grey50'),main='Current roads',legend=FALSE)
text(x=2.5,y=4.5,labels='existing road',cex=1.3)
text(x=2.5,y=2,labels='not currently\nroad',cex=1.3)
```

## 3. Landings layer(s)

Landings, or resource development locations, that are to be connected to the existing road network can be specified to the `projectRoads` method in a variety of forms.  These include specification as:

* A logical [`RasterLayer`](https://www.rdocumentation.org/packages/raster/versions/2.9-5/topics/Raster-class) {[`raster`](https://cran.r-project.org/web/packages/raster/index.html)} object with cell values of `TRUE` for landings,
* A [`SpatialPoints`](https://www.rdocumentation.org/packages/sp/versions/1.3-1/topics/SpatialPoints) {[`sp`](https://cran.r-project.org/web/packages/sp/index.html)} or [`SpatialPointsDataFrame`](https://www.rdocumentation.org/packages/sp/versions/1.3-1/topics/SpatialPointsDataFrame-class) {[`sp`](https://cran.r-project.org/web/packages/sp/index.html)} object with points representing landings,
* A matrix with at least two columns, with columns 1 and 2 representing x any y coordinates of landing locations respectively, or
* A [`RasterStack`](https://www.rdocumentation.org/packages/raster/versions/2.9-5/topics/Raster-class) {[`raster`](https://cran.r-project.org/web/packages/raster/index.html)} or [`RasterBrick`](https://www.rdocumentation.org/packages/raster/versions/2.9-5/topics/Raster-class) {[`raster`](https://cran.r-project.org/web/packages/raster/index.html)} object with each raster layer in the stack or brick representing a new time step for which new roads are to be simulated for (i.e. layer 1 represents landings at time t=1, layer 2 represents landings at time t=2, and so on).  Within each raster layer, cell values of `TRUE` represent new landings for that time-step.

The set of landings used in the CLUS roads simulation example is included within the CLUSexample data-set of this package.

```{r, include = FALSE}
knitr::opts_chunk$set(fig.width=5,fig.height=4.85)
```

```{r, fig.show='hold'}
## landings as spatial points
landings <- roads::CLUSexample$landings
## plot landings on top of cost raster
plot(costRaster,col=rastColours,main='Cost with landings')
plot(landings,add=TRUE,pch=19)
text(x=2.5,y=4.5,labels='existing road',cex=1.3)
points(x=5.6,y=4.5,pch=19,xpd=TRUE)
text(x=5.8,y=4.5,labels='landing',adj=c(0,0.4),xpd=TRUE)
```

# Simulation of new roads development

## 1. Snapping approach/method

This approach simply 'snaps' a landing (i.e., cutblock location) to the nearest existing road segment. Since the snapping is done for each landing it is also called an independent path method. 


```{r, fig.show='hold'}
## project new roads using the 'snap' approach
projRoads_snap <- roads::projectRoads(landings,costRaster,existingRoadsRast,roadMethod='snap')
## plot the cost raster, landings, and closest existing roads segmensts to the landings
plot(costRaster,col=rastColours,main='\'Snapped\' roads')
points(landings,pch=19)  ## landings points
points(projRoads_snap$roads.close.XY,pch=17)  ## closest point on existing roads
## add lines representing new roads, projected using the 'snap' approach
z <- lapply(1:length(landings),function(i){
  lines(rbind(landings@coords[i,],projRoads_snap$roads.close.XY[i,]),lty=3,lwd=2)
  })
## update legend
points(x=5.5,y=6,pch=19,xpd=TRUE)
text(x=5.7,y=6,labels='landing',adj=c(0,0.4),xpd=TRUE)
points(x=5.5,y=5.4,pch=17,xpd=TRUE)
text(x=5.7,y=5.6,labels='closest\nexisting\nroad seg',adj=c(0,1),xpd=TRUE)
lines(x=c(5.3,5.7),y=c(4.2,4.2),lty=3,lwd=2,xpd=TRUE)
text(x=5.75,y=4.2,labels='new road',adj=c(0,0.3),xpd=TRUE)
```

Using this approach, a few issues would arise: 

1. parallel roads are not realistic since there is no branching and this ultimately leads to increases in the amount of roads; 

2. costs are not included (i.e., slope and barriers like large waterbodies).

This means this approach, while simple to implement, would over estimate the amount of simulated roads.

## 2. Least Cost Paths (LCP) approach /method

This approach builds upon the snapping approach by assuming a 'cost directed' path (i.e., "as the wolf runs") for each landing to the existing road network. This includes the cost of barriers and impedance attributes. However, this approach requires a cost surface that needs to be estimated, then updated within the simulations and thus, requires greater computational time relative to the snapping approach. This data.table is then used to build a mathematical [graph](https://en.wikipedia.org/wiki/Graph_theory) using [igraph](http://igraph.org/r/).

Once the graph is built, it is simple to get the least cost path between any two verticies. Using [Dijkstra’s algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), the [shortest_paths](http://igraph.org/r/doc/distances.html) function is called in [igraph](http://igraph.org/r/doc/#R). Further, the graph can be easily updated to simulate the change in the cost surface from dynamically developing roads during the simulation. Note, that this dynamic behaviour would not be possible in a pre-solve of the road network. To implement a pre-solve approach the [igraph](http://igraph.org/r/doc/#R) function [all_shortest_paths](http://igraph.org/r/doc/distances.html) can be used to calculate all shortest paths between pairs of vertices; however, this is not included in the comparison.

```{r, include = FALSE}
knitr::opts_chunk$set(fig.width=7,fig.height=3.93)
```


```{r, fig.show='hold'}
## project new roads using the 'LCP' approach
projRoads_lcp <- roads::projectRoads(landings,costRaster,existingRoadsRast,roadMethod='lcp')
## isolate the new roads for plotting (TRUE for new road, NA elsewhere)
newroad_lcp <- projRoads_lcp$roads>0
newroad_lcp[existingRoadsRast] <- NA
newroad_lcp[!newroad_lcp] <- NA
## (left) plot the cost raster and landings
par(mfrow=c(1,2))
plot(costRaster,col=rastColours,main='Cost')
points(landings,pch=19)  ## landings points
## (right) plot the cost raster and overlay it with new roads
plot(costRaster,col=rastColours,main='Cost with new roads')
plot(newroad_lcp,col='grey30',add=TRUE,legend=FALSE)
points(landings,pch=19,col='red')  ## landings points
## legend
rect(-0.5,-1.7,0,-1.2,col='grey30',xpd=TRUE)
text(x=0.1,y=-1.45,labels='new road',adj=c(0,0.4),xpd=TRUE)
points(x=2.5,y=-1.45,pch=19,col='red',xpd=TRUE)
text(x=2.7,y=-1.45,labels='landing',adj=c(0,0.4),xpd=TRUE)
```
